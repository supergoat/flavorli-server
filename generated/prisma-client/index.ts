// Code generated by Prisma (prisma@1.31.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  address: (where?: AddressWhereInput) => Promise<boolean>;
  customer: (where?: CustomerWhereInput) => Promise<boolean>;
  menu: (where?: MenuWhereInput) => Promise<boolean>;
  menuCategory: (where?: MenuCategoryWhereInput) => Promise<boolean>;
  menuItem: (where?: MenuItemWhereInput) => Promise<boolean>;
  openingTime: (where?: OpeningTimeWhereInput) => Promise<boolean>;
  option: (where?: OptionWhereInput) => Promise<boolean>;
  optionItem: (where?: OptionItemWhereInput) => Promise<boolean>;
  order: (where?: OrderWhereInput) => Promise<boolean>;
  orderItem: (where?: OrderItemWhereInput) => Promise<boolean>;
  orderItemOption: (where?: OrderItemOptionWhereInput) => Promise<boolean>;
  orderItemOptionItem: (
    where?: OrderItemOptionItemWhereInput
  ) => Promise<boolean>;
  paymentMethod: (where?: PaymentMethodWhereInput) => Promise<boolean>;
  restaurant: (where?: RestaurantWhereInput) => Promise<boolean>;
  serviceTime: (where?: ServiceTimeWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  address: (where: AddressWhereUniqueInput) => AddressPromise;
  addresses: (args?: {
    where?: AddressWhereInput;
    orderBy?: AddressOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Address>;
  addressesConnection: (args?: {
    where?: AddressWhereInput;
    orderBy?: AddressOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AddressConnectionPromise;
  customer: (where: CustomerWhereUniqueInput) => CustomerPromise;
  customers: (args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Customer>;
  customersConnection: (args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CustomerConnectionPromise;
  menu: (where: MenuWhereUniqueInput) => MenuPromise;
  menus: (args?: {
    where?: MenuWhereInput;
    orderBy?: MenuOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Menu>;
  menusConnection: (args?: {
    where?: MenuWhereInput;
    orderBy?: MenuOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MenuConnectionPromise;
  menuCategory: (where: MenuCategoryWhereUniqueInput) => MenuCategoryPromise;
  menuCategories: (args?: {
    where?: MenuCategoryWhereInput;
    orderBy?: MenuCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<MenuCategory>;
  menuCategoriesConnection: (args?: {
    where?: MenuCategoryWhereInput;
    orderBy?: MenuCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MenuCategoryConnectionPromise;
  menuItem: (where: MenuItemWhereUniqueInput) => MenuItemPromise;
  menuItems: (args?: {
    where?: MenuItemWhereInput;
    orderBy?: MenuItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<MenuItem>;
  menuItemsConnection: (args?: {
    where?: MenuItemWhereInput;
    orderBy?: MenuItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MenuItemConnectionPromise;
  openingTime: (where: OpeningTimeWhereUniqueInput) => OpeningTimePromise;
  openingTimes: (args?: {
    where?: OpeningTimeWhereInput;
    orderBy?: OpeningTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<OpeningTime>;
  openingTimesConnection: (args?: {
    where?: OpeningTimeWhereInput;
    orderBy?: OpeningTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OpeningTimeConnectionPromise;
  option: (where: OptionWhereUniqueInput) => OptionPromise;
  options: (args?: {
    where?: OptionWhereInput;
    orderBy?: OptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Option>;
  optionsConnection: (args?: {
    where?: OptionWhereInput;
    orderBy?: OptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OptionConnectionPromise;
  optionItem: (where: OptionItemWhereUniqueInput) => OptionItemPromise;
  optionItems: (args?: {
    where?: OptionItemWhereInput;
    orderBy?: OptionItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<OptionItem>;
  optionItemsConnection: (args?: {
    where?: OptionItemWhereInput;
    orderBy?: OptionItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OptionItemConnectionPromise;
  order: (where: OrderWhereUniqueInput) => OrderPromise;
  orders: (args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Order>;
  ordersConnection: (args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OrderConnectionPromise;
  orderItem: (where: OrderItemWhereUniqueInput) => OrderItemPromise;
  orderItems: (args?: {
    where?: OrderItemWhereInput;
    orderBy?: OrderItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<OrderItem>;
  orderItemsConnection: (args?: {
    where?: OrderItemWhereInput;
    orderBy?: OrderItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OrderItemConnectionPromise;
  orderItemOption: (
    where: OrderItemOptionWhereUniqueInput
  ) => OrderItemOptionPromise;
  orderItemOptions: (args?: {
    where?: OrderItemOptionWhereInput;
    orderBy?: OrderItemOptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<OrderItemOption>;
  orderItemOptionsConnection: (args?: {
    where?: OrderItemOptionWhereInput;
    orderBy?: OrderItemOptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OrderItemOptionConnectionPromise;
  orderItemOptionItem: (
    where: OrderItemOptionItemWhereUniqueInput
  ) => OrderItemOptionItemPromise;
  orderItemOptionItems: (args?: {
    where?: OrderItemOptionItemWhereInput;
    orderBy?: OrderItemOptionItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<OrderItemOptionItem>;
  orderItemOptionItemsConnection: (args?: {
    where?: OrderItemOptionItemWhereInput;
    orderBy?: OrderItemOptionItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OrderItemOptionItemConnectionPromise;
  paymentMethod: (where: PaymentMethodWhereUniqueInput) => PaymentMethodPromise;
  paymentMethods: (args?: {
    where?: PaymentMethodWhereInput;
    orderBy?: PaymentMethodOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PaymentMethod>;
  paymentMethodsConnection: (args?: {
    where?: PaymentMethodWhereInput;
    orderBy?: PaymentMethodOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PaymentMethodConnectionPromise;
  restaurant: (where: RestaurantWhereUniqueInput) => RestaurantPromise;
  restaurants: (args?: {
    where?: RestaurantWhereInput;
    orderBy?: RestaurantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Restaurant>;
  restaurantsConnection: (args?: {
    where?: RestaurantWhereInput;
    orderBy?: RestaurantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RestaurantConnectionPromise;
  serviceTime: (where: ServiceTimeWhereUniqueInput) => ServiceTimePromise;
  serviceTimes: (args?: {
    where?: ServiceTimeWhereInput;
    orderBy?: ServiceTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ServiceTime>;
  serviceTimesConnection: (args?: {
    where?: ServiceTimeWhereInput;
    orderBy?: ServiceTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ServiceTimeConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAddress: (data: AddressCreateInput) => AddressPromise;
  updateAddress: (args: {
    data: AddressUpdateInput;
    where: AddressWhereUniqueInput;
  }) => AddressPromise;
  updateManyAddresses: (args: {
    data: AddressUpdateManyMutationInput;
    where?: AddressWhereInput;
  }) => BatchPayloadPromise;
  upsertAddress: (args: {
    where: AddressWhereUniqueInput;
    create: AddressCreateInput;
    update: AddressUpdateInput;
  }) => AddressPromise;
  deleteAddress: (where: AddressWhereUniqueInput) => AddressPromise;
  deleteManyAddresses: (where?: AddressWhereInput) => BatchPayloadPromise;
  createCustomer: (data: CustomerCreateInput) => CustomerPromise;
  updateCustomer: (args: {
    data: CustomerUpdateInput;
    where: CustomerWhereUniqueInput;
  }) => CustomerPromise;
  updateManyCustomers: (args: {
    data: CustomerUpdateManyMutationInput;
    where?: CustomerWhereInput;
  }) => BatchPayloadPromise;
  upsertCustomer: (args: {
    where: CustomerWhereUniqueInput;
    create: CustomerCreateInput;
    update: CustomerUpdateInput;
  }) => CustomerPromise;
  deleteCustomer: (where: CustomerWhereUniqueInput) => CustomerPromise;
  deleteManyCustomers: (where?: CustomerWhereInput) => BatchPayloadPromise;
  createMenu: (data: MenuCreateInput) => MenuPromise;
  updateMenu: (args: {
    data: MenuUpdateInput;
    where: MenuWhereUniqueInput;
  }) => MenuPromise;
  updateManyMenus: (args: {
    data: MenuUpdateManyMutationInput;
    where?: MenuWhereInput;
  }) => BatchPayloadPromise;
  upsertMenu: (args: {
    where: MenuWhereUniqueInput;
    create: MenuCreateInput;
    update: MenuUpdateInput;
  }) => MenuPromise;
  deleteMenu: (where: MenuWhereUniqueInput) => MenuPromise;
  deleteManyMenus: (where?: MenuWhereInput) => BatchPayloadPromise;
  createMenuCategory: (data: MenuCategoryCreateInput) => MenuCategoryPromise;
  updateMenuCategory: (args: {
    data: MenuCategoryUpdateInput;
    where: MenuCategoryWhereUniqueInput;
  }) => MenuCategoryPromise;
  updateManyMenuCategories: (args: {
    data: MenuCategoryUpdateManyMutationInput;
    where?: MenuCategoryWhereInput;
  }) => BatchPayloadPromise;
  upsertMenuCategory: (args: {
    where: MenuCategoryWhereUniqueInput;
    create: MenuCategoryCreateInput;
    update: MenuCategoryUpdateInput;
  }) => MenuCategoryPromise;
  deleteMenuCategory: (
    where: MenuCategoryWhereUniqueInput
  ) => MenuCategoryPromise;
  deleteManyMenuCategories: (
    where?: MenuCategoryWhereInput
  ) => BatchPayloadPromise;
  createMenuItem: (data: MenuItemCreateInput) => MenuItemPromise;
  updateMenuItem: (args: {
    data: MenuItemUpdateInput;
    where: MenuItemWhereUniqueInput;
  }) => MenuItemPromise;
  updateManyMenuItems: (args: {
    data: MenuItemUpdateManyMutationInput;
    where?: MenuItemWhereInput;
  }) => BatchPayloadPromise;
  upsertMenuItem: (args: {
    where: MenuItemWhereUniqueInput;
    create: MenuItemCreateInput;
    update: MenuItemUpdateInput;
  }) => MenuItemPromise;
  deleteMenuItem: (where: MenuItemWhereUniqueInput) => MenuItemPromise;
  deleteManyMenuItems: (where?: MenuItemWhereInput) => BatchPayloadPromise;
  createOpeningTime: (data: OpeningTimeCreateInput) => OpeningTimePromise;
  updateOpeningTime: (args: {
    data: OpeningTimeUpdateInput;
    where: OpeningTimeWhereUniqueInput;
  }) => OpeningTimePromise;
  updateManyOpeningTimes: (args: {
    data: OpeningTimeUpdateManyMutationInput;
    where?: OpeningTimeWhereInput;
  }) => BatchPayloadPromise;
  upsertOpeningTime: (args: {
    where: OpeningTimeWhereUniqueInput;
    create: OpeningTimeCreateInput;
    update: OpeningTimeUpdateInput;
  }) => OpeningTimePromise;
  deleteOpeningTime: (where: OpeningTimeWhereUniqueInput) => OpeningTimePromise;
  deleteManyOpeningTimes: (
    where?: OpeningTimeWhereInput
  ) => BatchPayloadPromise;
  createOption: (data: OptionCreateInput) => OptionPromise;
  updateOption: (args: {
    data: OptionUpdateInput;
    where: OptionWhereUniqueInput;
  }) => OptionPromise;
  updateManyOptions: (args: {
    data: OptionUpdateManyMutationInput;
    where?: OptionWhereInput;
  }) => BatchPayloadPromise;
  upsertOption: (args: {
    where: OptionWhereUniqueInput;
    create: OptionCreateInput;
    update: OptionUpdateInput;
  }) => OptionPromise;
  deleteOption: (where: OptionWhereUniqueInput) => OptionPromise;
  deleteManyOptions: (where?: OptionWhereInput) => BatchPayloadPromise;
  createOptionItem: (data: OptionItemCreateInput) => OptionItemPromise;
  updateOptionItem: (args: {
    data: OptionItemUpdateInput;
    where: OptionItemWhereUniqueInput;
  }) => OptionItemPromise;
  updateManyOptionItems: (args: {
    data: OptionItemUpdateManyMutationInput;
    where?: OptionItemWhereInput;
  }) => BatchPayloadPromise;
  upsertOptionItem: (args: {
    where: OptionItemWhereUniqueInput;
    create: OptionItemCreateInput;
    update: OptionItemUpdateInput;
  }) => OptionItemPromise;
  deleteOptionItem: (where: OptionItemWhereUniqueInput) => OptionItemPromise;
  deleteManyOptionItems: (where?: OptionItemWhereInput) => BatchPayloadPromise;
  createOrder: (data: OrderCreateInput) => OrderPromise;
  updateOrder: (args: {
    data: OrderUpdateInput;
    where: OrderWhereUniqueInput;
  }) => OrderPromise;
  updateManyOrders: (args: {
    data: OrderUpdateManyMutationInput;
    where?: OrderWhereInput;
  }) => BatchPayloadPromise;
  upsertOrder: (args: {
    where: OrderWhereUniqueInput;
    create: OrderCreateInput;
    update: OrderUpdateInput;
  }) => OrderPromise;
  deleteOrder: (where: OrderWhereUniqueInput) => OrderPromise;
  deleteManyOrders: (where?: OrderWhereInput) => BatchPayloadPromise;
  createOrderItem: (data: OrderItemCreateInput) => OrderItemPromise;
  updateOrderItem: (args: {
    data: OrderItemUpdateInput;
    where: OrderItemWhereUniqueInput;
  }) => OrderItemPromise;
  updateManyOrderItems: (args: {
    data: OrderItemUpdateManyMutationInput;
    where?: OrderItemWhereInput;
  }) => BatchPayloadPromise;
  upsertOrderItem: (args: {
    where: OrderItemWhereUniqueInput;
    create: OrderItemCreateInput;
    update: OrderItemUpdateInput;
  }) => OrderItemPromise;
  deleteOrderItem: (where: OrderItemWhereUniqueInput) => OrderItemPromise;
  deleteManyOrderItems: (where?: OrderItemWhereInput) => BatchPayloadPromise;
  createOrderItemOption: (
    data: OrderItemOptionCreateInput
  ) => OrderItemOptionPromise;
  updateOrderItemOption: (args: {
    data: OrderItemOptionUpdateInput;
    where: OrderItemOptionWhereUniqueInput;
  }) => OrderItemOptionPromise;
  updateManyOrderItemOptions: (args: {
    data: OrderItemOptionUpdateManyMutationInput;
    where?: OrderItemOptionWhereInput;
  }) => BatchPayloadPromise;
  upsertOrderItemOption: (args: {
    where: OrderItemOptionWhereUniqueInput;
    create: OrderItemOptionCreateInput;
    update: OrderItemOptionUpdateInput;
  }) => OrderItemOptionPromise;
  deleteOrderItemOption: (
    where: OrderItemOptionWhereUniqueInput
  ) => OrderItemOptionPromise;
  deleteManyOrderItemOptions: (
    where?: OrderItemOptionWhereInput
  ) => BatchPayloadPromise;
  createOrderItemOptionItem: (
    data: OrderItemOptionItemCreateInput
  ) => OrderItemOptionItemPromise;
  updateOrderItemOptionItem: (args: {
    data: OrderItemOptionItemUpdateInput;
    where: OrderItemOptionItemWhereUniqueInput;
  }) => OrderItemOptionItemPromise;
  updateManyOrderItemOptionItems: (args: {
    data: OrderItemOptionItemUpdateManyMutationInput;
    where?: OrderItemOptionItemWhereInput;
  }) => BatchPayloadPromise;
  upsertOrderItemOptionItem: (args: {
    where: OrderItemOptionItemWhereUniqueInput;
    create: OrderItemOptionItemCreateInput;
    update: OrderItemOptionItemUpdateInput;
  }) => OrderItemOptionItemPromise;
  deleteOrderItemOptionItem: (
    where: OrderItemOptionItemWhereUniqueInput
  ) => OrderItemOptionItemPromise;
  deleteManyOrderItemOptionItems: (
    where?: OrderItemOptionItemWhereInput
  ) => BatchPayloadPromise;
  createPaymentMethod: (data: PaymentMethodCreateInput) => PaymentMethodPromise;
  updatePaymentMethod: (args: {
    data: PaymentMethodUpdateInput;
    where: PaymentMethodWhereUniqueInput;
  }) => PaymentMethodPromise;
  updateManyPaymentMethods: (args: {
    data: PaymentMethodUpdateManyMutationInput;
    where?: PaymentMethodWhereInput;
  }) => BatchPayloadPromise;
  upsertPaymentMethod: (args: {
    where: PaymentMethodWhereUniqueInput;
    create: PaymentMethodCreateInput;
    update: PaymentMethodUpdateInput;
  }) => PaymentMethodPromise;
  deletePaymentMethod: (
    where: PaymentMethodWhereUniqueInput
  ) => PaymentMethodPromise;
  deleteManyPaymentMethods: (
    where?: PaymentMethodWhereInput
  ) => BatchPayloadPromise;
  createRestaurant: (data: RestaurantCreateInput) => RestaurantPromise;
  updateRestaurant: (args: {
    data: RestaurantUpdateInput;
    where: RestaurantWhereUniqueInput;
  }) => RestaurantPromise;
  updateManyRestaurants: (args: {
    data: RestaurantUpdateManyMutationInput;
    where?: RestaurantWhereInput;
  }) => BatchPayloadPromise;
  upsertRestaurant: (args: {
    where: RestaurantWhereUniqueInput;
    create: RestaurantCreateInput;
    update: RestaurantUpdateInput;
  }) => RestaurantPromise;
  deleteRestaurant: (where: RestaurantWhereUniqueInput) => RestaurantPromise;
  deleteManyRestaurants: (where?: RestaurantWhereInput) => BatchPayloadPromise;
  createServiceTime: (data: ServiceTimeCreateInput) => ServiceTimePromise;
  updateServiceTime: (args: {
    data: ServiceTimeUpdateInput;
    where: ServiceTimeWhereUniqueInput;
  }) => ServiceTimePromise;
  updateManyServiceTimes: (args: {
    data: ServiceTimeUpdateManyMutationInput;
    where?: ServiceTimeWhereInput;
  }) => BatchPayloadPromise;
  upsertServiceTime: (args: {
    where: ServiceTimeWhereUniqueInput;
    create: ServiceTimeCreateInput;
    update: ServiceTimeUpdateInput;
  }) => ServiceTimePromise;
  deleteServiceTime: (where: ServiceTimeWhereUniqueInput) => ServiceTimePromise;
  deleteManyServiceTimes: (
    where?: ServiceTimeWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  address: (
    where?: AddressSubscriptionWhereInput
  ) => AddressSubscriptionPayloadSubscription;
  customer: (
    where?: CustomerSubscriptionWhereInput
  ) => CustomerSubscriptionPayloadSubscription;
  menu: (
    where?: MenuSubscriptionWhereInput
  ) => MenuSubscriptionPayloadSubscription;
  menuCategory: (
    where?: MenuCategorySubscriptionWhereInput
  ) => MenuCategorySubscriptionPayloadSubscription;
  menuItem: (
    where?: MenuItemSubscriptionWhereInput
  ) => MenuItemSubscriptionPayloadSubscription;
  openingTime: (
    where?: OpeningTimeSubscriptionWhereInput
  ) => OpeningTimeSubscriptionPayloadSubscription;
  option: (
    where?: OptionSubscriptionWhereInput
  ) => OptionSubscriptionPayloadSubscription;
  optionItem: (
    where?: OptionItemSubscriptionWhereInput
  ) => OptionItemSubscriptionPayloadSubscription;
  order: (
    where?: OrderSubscriptionWhereInput
  ) => OrderSubscriptionPayloadSubscription;
  orderItem: (
    where?: OrderItemSubscriptionWhereInput
  ) => OrderItemSubscriptionPayloadSubscription;
  orderItemOption: (
    where?: OrderItemOptionSubscriptionWhereInput
  ) => OrderItemOptionSubscriptionPayloadSubscription;
  orderItemOptionItem: (
    where?: OrderItemOptionItemSubscriptionWhereInput
  ) => OrderItemOptionItemSubscriptionPayloadSubscription;
  paymentMethod: (
    where?: PaymentMethodSubscriptionWhereInput
  ) => PaymentMethodSubscriptionPayloadSubscription;
  restaurant: (
    where?: RestaurantSubscriptionWhereInput
  ) => RestaurantSubscriptionPayloadSubscription;
  serviceTime: (
    where?: ServiceTimeSubscriptionWhereInput
  ) => ServiceTimeSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type OpeningTimeOrderByInput = "id_ASC" | "id_DESC";

export type MenuOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ServiceTimeOrderByInput = "id_ASC" | "id_DESC";

export type MenuCategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "available_ASC"
  | "available_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MenuItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "price_ASC"
  | "price_DESC"
  | "image_ASC"
  | "image_DESC"
  | "available_ASC"
  | "available_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type OptionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "min_ASC"
  | "min_DESC"
  | "max_ASC"
  | "max_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type OptionItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "price_ASC"
  | "price_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AddressOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "number_ASC"
  | "number_DESC"
  | "streetName_ASC"
  | "streetName_DESC"
  | "city_ASC"
  | "city_DESC"
  | "postalCode_ASC"
  | "postalCode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type OrderOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "orderNo_ASC"
  | "orderNo_DESC"
  | "paymentIntentId_ASC"
  | "paymentIntentId_DESC"
  | "status_ASC"
  | "status_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "dueAt_ASC"
  | "dueAt_DESC"
  | "delayedBy_ASC"
  | "delayedBy_DESC"
  | "total_ASC"
  | "total_DESC"
  | "priceAdjustment_ASC"
  | "priceAdjustment_DESC"
  | "cancelReason_ASC"
  | "cancelReason_DESC"
  | "priceAdjustmentReason_ASC"
  | "priceAdjustmentReason_DESC";

export type OrderItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "price_ASC"
  | "price_DESC"
  | "image_ASC"
  | "image_DESC"
  | "quantity_ASC"
  | "quantity_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type OrderItemOptionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type OrderItemOptionItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "price_ASC"
  | "price_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CustomerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "name_ASC"
  | "name_DESC"
  | "tel_ASC"
  | "tel_DESC"
  | "customerStripeId_ASC"
  | "customerStripeId_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PaymentMethodOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "payment_method_id_ASC"
  | "payment_method_id_DESC"
  | "brand_ASC"
  | "brand_DESC"
  | "last4_ASC"
  | "last4_DESC";

export type RestaurantOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "tel_ASC"
  | "tel_DESC"
  | "image_ASC"
  | "image_DESC"
  | "logo_ASC"
  | "logo_DESC"
  | "description_ASC"
  | "description_DESC"
  | "status_ASC"
  | "status_DESC"
  | "averageBusyPreparationTime_ASC"
  | "averageBusyPreparationTime_DESC"
  | "averagePreparationTime_ASC"
  | "averagePreparationTime_DESC"
  | "isConnected_ASC"
  | "isConnected_DESC"
  | "stripe_user_id_ASC"
  | "stripe_user_id_DESC"
  | "stripe_publishable_key_ASC"
  | "stripe_publishable_key_DESC"
  | "access_token_ASC"
  | "access_token_DESC"
  | "refresh_token_ASC"
  | "refresh_token_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type AddressWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface OpeningTimeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  restaurant?: RestaurantWhereInput;
  AND?: OpeningTimeWhereInput[] | OpeningTimeWhereInput;
  OR?: OpeningTimeWhereInput[] | OpeningTimeWhereInput;
  NOT?: OpeningTimeWhereInput[] | OpeningTimeWhereInput;
}

export interface RestaurantWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  address?: AddressWhereInput;
  tel?: String;
  tel_not?: String;
  tel_in?: String[] | String;
  tel_not_in?: String[] | String;
  tel_lt?: String;
  tel_lte?: String;
  tel_gt?: String;
  tel_gte?: String;
  tel_contains?: String;
  tel_not_contains?: String;
  tel_starts_with?: String;
  tel_not_starts_with?: String;
  tel_ends_with?: String;
  tel_not_ends_with?: String;
  image?: String;
  image_not?: String;
  image_in?: String[] | String;
  image_not_in?: String[] | String;
  image_lt?: String;
  image_lte?: String;
  image_gt?: String;
  image_gte?: String;
  image_contains?: String;
  image_not_contains?: String;
  image_starts_with?: String;
  image_not_starts_with?: String;
  image_ends_with?: String;
  image_not_ends_with?: String;
  logo?: String;
  logo_not?: String;
  logo_in?: String[] | String;
  logo_not_in?: String[] | String;
  logo_lt?: String;
  logo_lte?: String;
  logo_gt?: String;
  logo_gte?: String;
  logo_contains?: String;
  logo_not_contains?: String;
  logo_starts_with?: String;
  logo_not_starts_with?: String;
  logo_ends_with?: String;
  logo_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  status?: String;
  status_not?: String;
  status_in?: String[] | String;
  status_not_in?: String[] | String;
  status_lt?: String;
  status_lte?: String;
  status_gt?: String;
  status_gte?: String;
  status_contains?: String;
  status_not_contains?: String;
  status_starts_with?: String;
  status_not_starts_with?: String;
  status_ends_with?: String;
  status_not_ends_with?: String;
  openingTimes_every?: OpeningTimeWhereInput;
  openingTimes_some?: OpeningTimeWhereInput;
  openingTimes_none?: OpeningTimeWhereInput;
  averageBusyPreparationTime?: String;
  averageBusyPreparationTime_not?: String;
  averageBusyPreparationTime_in?: String[] | String;
  averageBusyPreparationTime_not_in?: String[] | String;
  averageBusyPreparationTime_lt?: String;
  averageBusyPreparationTime_lte?: String;
  averageBusyPreparationTime_gt?: String;
  averageBusyPreparationTime_gte?: String;
  averageBusyPreparationTime_contains?: String;
  averageBusyPreparationTime_not_contains?: String;
  averageBusyPreparationTime_starts_with?: String;
  averageBusyPreparationTime_not_starts_with?: String;
  averageBusyPreparationTime_ends_with?: String;
  averageBusyPreparationTime_not_ends_with?: String;
  averagePreparationTime?: String;
  averagePreparationTime_not?: String;
  averagePreparationTime_in?: String[] | String;
  averagePreparationTime_not_in?: String[] | String;
  averagePreparationTime_lt?: String;
  averagePreparationTime_lte?: String;
  averagePreparationTime_gt?: String;
  averagePreparationTime_gte?: String;
  averagePreparationTime_contains?: String;
  averagePreparationTime_not_contains?: String;
  averagePreparationTime_starts_with?: String;
  averagePreparationTime_not_starts_with?: String;
  averagePreparationTime_ends_with?: String;
  averagePreparationTime_not_ends_with?: String;
  menus_every?: MenuWhereInput;
  menus_some?: MenuWhereInput;
  menus_none?: MenuWhereInput;
  isConnected?: Boolean;
  isConnected_not?: Boolean;
  stripe_user_id?: String;
  stripe_user_id_not?: String;
  stripe_user_id_in?: String[] | String;
  stripe_user_id_not_in?: String[] | String;
  stripe_user_id_lt?: String;
  stripe_user_id_lte?: String;
  stripe_user_id_gt?: String;
  stripe_user_id_gte?: String;
  stripe_user_id_contains?: String;
  stripe_user_id_not_contains?: String;
  stripe_user_id_starts_with?: String;
  stripe_user_id_not_starts_with?: String;
  stripe_user_id_ends_with?: String;
  stripe_user_id_not_ends_with?: String;
  stripe_publishable_key?: String;
  stripe_publishable_key_not?: String;
  stripe_publishable_key_in?: String[] | String;
  stripe_publishable_key_not_in?: String[] | String;
  stripe_publishable_key_lt?: String;
  stripe_publishable_key_lte?: String;
  stripe_publishable_key_gt?: String;
  stripe_publishable_key_gte?: String;
  stripe_publishable_key_contains?: String;
  stripe_publishable_key_not_contains?: String;
  stripe_publishable_key_starts_with?: String;
  stripe_publishable_key_not_starts_with?: String;
  stripe_publishable_key_ends_with?: String;
  stripe_publishable_key_not_ends_with?: String;
  access_token?: String;
  access_token_not?: String;
  access_token_in?: String[] | String;
  access_token_not_in?: String[] | String;
  access_token_lt?: String;
  access_token_lte?: String;
  access_token_gt?: String;
  access_token_gte?: String;
  access_token_contains?: String;
  access_token_not_contains?: String;
  access_token_starts_with?: String;
  access_token_not_starts_with?: String;
  access_token_ends_with?: String;
  access_token_not_ends_with?: String;
  refresh_token?: String;
  refresh_token_not?: String;
  refresh_token_in?: String[] | String;
  refresh_token_not_in?: String[] | String;
  refresh_token_lt?: String;
  refresh_token_lte?: String;
  refresh_token_gt?: String;
  refresh_token_gte?: String;
  refresh_token_contains?: String;
  refresh_token_not_contains?: String;
  refresh_token_starts_with?: String;
  refresh_token_not_starts_with?: String;
  refresh_token_ends_with?: String;
  refresh_token_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: RestaurantWhereInput[] | RestaurantWhereInput;
  OR?: RestaurantWhereInput[] | RestaurantWhereInput;
  NOT?: RestaurantWhereInput[] | RestaurantWhereInput;
}

export interface AddressWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  number?: String;
  number_not?: String;
  number_in?: String[] | String;
  number_not_in?: String[] | String;
  number_lt?: String;
  number_lte?: String;
  number_gt?: String;
  number_gte?: String;
  number_contains?: String;
  number_not_contains?: String;
  number_starts_with?: String;
  number_not_starts_with?: String;
  number_ends_with?: String;
  number_not_ends_with?: String;
  streetName?: String;
  streetName_not?: String;
  streetName_in?: String[] | String;
  streetName_not_in?: String[] | String;
  streetName_lt?: String;
  streetName_lte?: String;
  streetName_gt?: String;
  streetName_gte?: String;
  streetName_contains?: String;
  streetName_not_contains?: String;
  streetName_starts_with?: String;
  streetName_not_starts_with?: String;
  streetName_ends_with?: String;
  streetName_not_ends_with?: String;
  city?: String;
  city_not?: String;
  city_in?: String[] | String;
  city_not_in?: String[] | String;
  city_lt?: String;
  city_lte?: String;
  city_gt?: String;
  city_gte?: String;
  city_contains?: String;
  city_not_contains?: String;
  city_starts_with?: String;
  city_not_starts_with?: String;
  city_ends_with?: String;
  city_not_ends_with?: String;
  postalCode?: String;
  postalCode_not?: String;
  postalCode_in?: String[] | String;
  postalCode_not_in?: String[] | String;
  postalCode_lt?: String;
  postalCode_lte?: String;
  postalCode_gt?: String;
  postalCode_gte?: String;
  postalCode_contains?: String;
  postalCode_not_contains?: String;
  postalCode_starts_with?: String;
  postalCode_not_starts_with?: String;
  postalCode_ends_with?: String;
  postalCode_not_ends_with?: String;
  restaurant?: RestaurantWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: AddressWhereInput[] | AddressWhereInput;
  OR?: AddressWhereInput[] | AddressWhereInput;
  NOT?: AddressWhereInput[] | AddressWhereInput;
}

export interface MenuWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  restaurant?: RestaurantWhereInput;
  serviceTimes_every?: ServiceTimeWhereInput;
  serviceTimes_some?: ServiceTimeWhereInput;
  serviceTimes_none?: ServiceTimeWhereInput;
  categories_every?: MenuCategoryWhereInput;
  categories_some?: MenuCategoryWhereInput;
  categories_none?: MenuCategoryWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: MenuWhereInput[] | MenuWhereInput;
  OR?: MenuWhereInput[] | MenuWhereInput;
  NOT?: MenuWhereInput[] | MenuWhereInput;
}

export interface ServiceTimeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  menu?: MenuWhereInput;
  AND?: ServiceTimeWhereInput[] | ServiceTimeWhereInput;
  OR?: ServiceTimeWhereInput[] | ServiceTimeWhereInput;
  NOT?: ServiceTimeWhereInput[] | ServiceTimeWhereInput;
}

export interface MenuCategoryWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  menu?: MenuWhereInput;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  available?: Boolean;
  available_not?: Boolean;
  items_every?: MenuItemWhereInput;
  items_some?: MenuItemWhereInput;
  items_none?: MenuItemWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: MenuCategoryWhereInput[] | MenuCategoryWhereInput;
  OR?: MenuCategoryWhereInput[] | MenuCategoryWhereInput;
  NOT?: MenuCategoryWhereInput[] | MenuCategoryWhereInput;
}

export interface MenuItemWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  price?: String;
  price_not?: String;
  price_in?: String[] | String;
  price_not_in?: String[] | String;
  price_lt?: String;
  price_lte?: String;
  price_gt?: String;
  price_gte?: String;
  price_contains?: String;
  price_not_contains?: String;
  price_starts_with?: String;
  price_not_starts_with?: String;
  price_ends_with?: String;
  price_not_ends_with?: String;
  image?: String;
  image_not?: String;
  image_in?: String[] | String;
  image_not_in?: String[] | String;
  image_lt?: String;
  image_lte?: String;
  image_gt?: String;
  image_gte?: String;
  image_contains?: String;
  image_not_contains?: String;
  image_starts_with?: String;
  image_not_starts_with?: String;
  image_ends_with?: String;
  image_not_ends_with?: String;
  available?: Boolean;
  available_not?: Boolean;
  category?: MenuCategoryWhereInput;
  options_every?: OptionWhereInput;
  options_some?: OptionWhereInput;
  options_none?: OptionWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: MenuItemWhereInput[] | MenuItemWhereInput;
  OR?: MenuItemWhereInput[] | MenuItemWhereInput;
  NOT?: MenuItemWhereInput[] | MenuItemWhereInput;
}

export interface OptionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  min?: String;
  min_not?: String;
  min_in?: String[] | String;
  min_not_in?: String[] | String;
  min_lt?: String;
  min_lte?: String;
  min_gt?: String;
  min_gte?: String;
  min_contains?: String;
  min_not_contains?: String;
  min_starts_with?: String;
  min_not_starts_with?: String;
  min_ends_with?: String;
  min_not_ends_with?: String;
  max?: String;
  max_not?: String;
  max_in?: String[] | String;
  max_not_in?: String[] | String;
  max_lt?: String;
  max_lte?: String;
  max_gt?: String;
  max_gte?: String;
  max_contains?: String;
  max_not_contains?: String;
  max_starts_with?: String;
  max_not_starts_with?: String;
  max_ends_with?: String;
  max_not_ends_with?: String;
  items_every?: OptionItemWhereInput;
  items_some?: OptionItemWhereInput;
  items_none?: OptionItemWhereInput;
  menuItems_every?: MenuItemWhereInput;
  menuItems_some?: MenuItemWhereInput;
  menuItems_none?: MenuItemWhereInput;
  restaurant?: RestaurantWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: OptionWhereInput[] | OptionWhereInput;
  OR?: OptionWhereInput[] | OptionWhereInput;
  NOT?: OptionWhereInput[] | OptionWhereInput;
}

export interface OptionItemWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  price?: String;
  price_not?: String;
  price_in?: String[] | String;
  price_not_in?: String[] | String;
  price_lt?: String;
  price_lte?: String;
  price_gt?: String;
  price_gte?: String;
  price_contains?: String;
  price_not_contains?: String;
  price_starts_with?: String;
  price_not_starts_with?: String;
  price_ends_with?: String;
  price_not_ends_with?: String;
  option?: OptionWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: OptionItemWhereInput[] | OptionItemWhereInput;
  OR?: OptionItemWhereInput[] | OptionItemWhereInput;
  NOT?: OptionItemWhereInput[] | OptionItemWhereInput;
}

export type CustomerWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface OrderWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  orderNo?: Int;
  orderNo_not?: Int;
  orderNo_in?: Int[] | Int;
  orderNo_not_in?: Int[] | Int;
  orderNo_lt?: Int;
  orderNo_lte?: Int;
  orderNo_gt?: Int;
  orderNo_gte?: Int;
  paymentIntentId?: String;
  paymentIntentId_not?: String;
  paymentIntentId_in?: String[] | String;
  paymentIntentId_not_in?: String[] | String;
  paymentIntentId_lt?: String;
  paymentIntentId_lte?: String;
  paymentIntentId_gt?: String;
  paymentIntentId_gte?: String;
  paymentIntentId_contains?: String;
  paymentIntentId_not_contains?: String;
  paymentIntentId_starts_with?: String;
  paymentIntentId_not_starts_with?: String;
  paymentIntentId_ends_with?: String;
  paymentIntentId_not_ends_with?: String;
  status?: String;
  status_not?: String;
  status_in?: String[] | String;
  status_not_in?: String[] | String;
  status_lt?: String;
  status_lte?: String;
  status_gt?: String;
  status_gte?: String;
  status_contains?: String;
  status_not_contains?: String;
  status_starts_with?: String;
  status_not_starts_with?: String;
  status_ends_with?: String;
  status_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  dueAt?: DateTimeInput;
  dueAt_not?: DateTimeInput;
  dueAt_in?: DateTimeInput[] | DateTimeInput;
  dueAt_not_in?: DateTimeInput[] | DateTimeInput;
  dueAt_lt?: DateTimeInput;
  dueAt_lte?: DateTimeInput;
  dueAt_gt?: DateTimeInput;
  dueAt_gte?: DateTimeInput;
  delayedBy?: Int;
  delayedBy_not?: Int;
  delayedBy_in?: Int[] | Int;
  delayedBy_not_in?: Int[] | Int;
  delayedBy_lt?: Int;
  delayedBy_lte?: Int;
  delayedBy_gt?: Int;
  delayedBy_gte?: Int;
  restaurant?: RestaurantWhereInput;
  customer?: CustomerWhereInput;
  items_every?: OrderItemWhereInput;
  items_some?: OrderItemWhereInput;
  items_none?: OrderItemWhereInput;
  total?: String;
  total_not?: String;
  total_in?: String[] | String;
  total_not_in?: String[] | String;
  total_lt?: String;
  total_lte?: String;
  total_gt?: String;
  total_gte?: String;
  total_contains?: String;
  total_not_contains?: String;
  total_starts_with?: String;
  total_not_starts_with?: String;
  total_ends_with?: String;
  total_not_ends_with?: String;
  priceAdjustment?: String;
  priceAdjustment_not?: String;
  priceAdjustment_in?: String[] | String;
  priceAdjustment_not_in?: String[] | String;
  priceAdjustment_lt?: String;
  priceAdjustment_lte?: String;
  priceAdjustment_gt?: String;
  priceAdjustment_gte?: String;
  priceAdjustment_contains?: String;
  priceAdjustment_not_contains?: String;
  priceAdjustment_starts_with?: String;
  priceAdjustment_not_starts_with?: String;
  priceAdjustment_ends_with?: String;
  priceAdjustment_not_ends_with?: String;
  cancelReason?: String;
  cancelReason_not?: String;
  cancelReason_in?: String[] | String;
  cancelReason_not_in?: String[] | String;
  cancelReason_lt?: String;
  cancelReason_lte?: String;
  cancelReason_gt?: String;
  cancelReason_gte?: String;
  cancelReason_contains?: String;
  cancelReason_not_contains?: String;
  cancelReason_starts_with?: String;
  cancelReason_not_starts_with?: String;
  cancelReason_ends_with?: String;
  cancelReason_not_ends_with?: String;
  priceAdjustmentReason?: String;
  priceAdjustmentReason_not?: String;
  priceAdjustmentReason_in?: String[] | String;
  priceAdjustmentReason_not_in?: String[] | String;
  priceAdjustmentReason_lt?: String;
  priceAdjustmentReason_lte?: String;
  priceAdjustmentReason_gt?: String;
  priceAdjustmentReason_gte?: String;
  priceAdjustmentReason_contains?: String;
  priceAdjustmentReason_not_contains?: String;
  priceAdjustmentReason_starts_with?: String;
  priceAdjustmentReason_not_starts_with?: String;
  priceAdjustmentReason_ends_with?: String;
  priceAdjustmentReason_not_ends_with?: String;
  AND?: OrderWhereInput[] | OrderWhereInput;
  OR?: OrderWhereInput[] | OrderWhereInput;
  NOT?: OrderWhereInput[] | OrderWhereInput;
}

export interface CustomerWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  tel?: String;
  tel_not?: String;
  tel_in?: String[] | String;
  tel_not_in?: String[] | String;
  tel_lt?: String;
  tel_lte?: String;
  tel_gt?: String;
  tel_gte?: String;
  tel_contains?: String;
  tel_not_contains?: String;
  tel_starts_with?: String;
  tel_not_starts_with?: String;
  tel_ends_with?: String;
  tel_not_ends_with?: String;
  customerStripeId?: String;
  customerStripeId_not?: String;
  customerStripeId_in?: String[] | String;
  customerStripeId_not_in?: String[] | String;
  customerStripeId_lt?: String;
  customerStripeId_lte?: String;
  customerStripeId_gt?: String;
  customerStripeId_gte?: String;
  customerStripeId_contains?: String;
  customerStripeId_not_contains?: String;
  customerStripeId_starts_with?: String;
  customerStripeId_not_starts_with?: String;
  customerStripeId_ends_with?: String;
  customerStripeId_not_ends_with?: String;
  orders_every?: OrderWhereInput;
  orders_some?: OrderWhereInput;
  orders_none?: OrderWhereInput;
  paymentMethod?: PaymentMethodWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: CustomerWhereInput[] | CustomerWhereInput;
  OR?: CustomerWhereInput[] | CustomerWhereInput;
  NOT?: CustomerWhereInput[] | CustomerWhereInput;
}

export interface PaymentMethodWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  payment_method_id?: String;
  payment_method_id_not?: String;
  payment_method_id_in?: String[] | String;
  payment_method_id_not_in?: String[] | String;
  payment_method_id_lt?: String;
  payment_method_id_lte?: String;
  payment_method_id_gt?: String;
  payment_method_id_gte?: String;
  payment_method_id_contains?: String;
  payment_method_id_not_contains?: String;
  payment_method_id_starts_with?: String;
  payment_method_id_not_starts_with?: String;
  payment_method_id_ends_with?: String;
  payment_method_id_not_ends_with?: String;
  brand?: String;
  brand_not?: String;
  brand_in?: String[] | String;
  brand_not_in?: String[] | String;
  brand_lt?: String;
  brand_lte?: String;
  brand_gt?: String;
  brand_gte?: String;
  brand_contains?: String;
  brand_not_contains?: String;
  brand_starts_with?: String;
  brand_not_starts_with?: String;
  brand_ends_with?: String;
  brand_not_ends_with?: String;
  last4?: String;
  last4_not?: String;
  last4_in?: String[] | String;
  last4_not_in?: String[] | String;
  last4_lt?: String;
  last4_lte?: String;
  last4_gt?: String;
  last4_gte?: String;
  last4_contains?: String;
  last4_not_contains?: String;
  last4_starts_with?: String;
  last4_not_starts_with?: String;
  last4_ends_with?: String;
  last4_not_ends_with?: String;
  customer?: CustomerWhereInput;
  AND?: PaymentMethodWhereInput[] | PaymentMethodWhereInput;
  OR?: PaymentMethodWhereInput[] | PaymentMethodWhereInput;
  NOT?: PaymentMethodWhereInput[] | PaymentMethodWhereInput;
}

export interface OrderItemWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  price?: String;
  price_not?: String;
  price_in?: String[] | String;
  price_not_in?: String[] | String;
  price_lt?: String;
  price_lte?: String;
  price_gt?: String;
  price_gte?: String;
  price_contains?: String;
  price_not_contains?: String;
  price_starts_with?: String;
  price_not_starts_with?: String;
  price_ends_with?: String;
  price_not_ends_with?: String;
  image?: String;
  image_not?: String;
  image_in?: String[] | String;
  image_not_in?: String[] | String;
  image_lt?: String;
  image_lte?: String;
  image_gt?: String;
  image_gte?: String;
  image_contains?: String;
  image_not_contains?: String;
  image_starts_with?: String;
  image_not_starts_with?: String;
  image_ends_with?: String;
  image_not_ends_with?: String;
  quantity?: Int;
  quantity_not?: Int;
  quantity_in?: Int[] | Int;
  quantity_not_in?: Int[] | Int;
  quantity_lt?: Int;
  quantity_lte?: Int;
  quantity_gt?: Int;
  quantity_gte?: Int;
  options_every?: OrderItemOptionWhereInput;
  options_some?: OrderItemOptionWhereInput;
  options_none?: OrderItemOptionWhereInput;
  order?: OrderWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: OrderItemWhereInput[] | OrderItemWhereInput;
  OR?: OrderItemWhereInput[] | OrderItemWhereInput;
  NOT?: OrderItemWhereInput[] | OrderItemWhereInput;
}

export interface OrderItemOptionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  items_every?: OrderItemOptionItemWhereInput;
  items_some?: OrderItemOptionItemWhereInput;
  items_none?: OrderItemOptionItemWhereInput;
  orderItem?: OrderItemWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: OrderItemOptionWhereInput[] | OrderItemOptionWhereInput;
  OR?: OrderItemOptionWhereInput[] | OrderItemOptionWhereInput;
  NOT?: OrderItemOptionWhereInput[] | OrderItemOptionWhereInput;
}

export interface OrderItemOptionItemWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  price?: String;
  price_not?: String;
  price_in?: String[] | String;
  price_not_in?: String[] | String;
  price_lt?: String;
  price_lte?: String;
  price_gt?: String;
  price_gte?: String;
  price_contains?: String;
  price_not_contains?: String;
  price_starts_with?: String;
  price_not_starts_with?: String;
  price_ends_with?: String;
  price_not_ends_with?: String;
  option?: OrderItemOptionWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: OrderItemOptionItemWhereInput[] | OrderItemOptionItemWhereInput;
  OR?: OrderItemOptionItemWhereInput[] | OrderItemOptionItemWhereInput;
  NOT?: OrderItemOptionItemWhereInput[] | OrderItemOptionItemWhereInput;
}

export type MenuWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type MenuCategoryWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type MenuItemWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type OpeningTimeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type OptionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type OptionItemWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type OrderWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type OrderItemWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type OrderItemOptionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type OrderItemOptionItemWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type PaymentMethodWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  payment_method_id?: String;
}>;

export type RestaurantWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export type ServiceTimeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AddressCreateInput {
  id?: ID_Input;
  number: String;
  streetName: String;
  city: String;
  postalCode: String;
  restaurant: RestaurantCreateOneWithoutAddressInput;
}

export interface RestaurantCreateOneWithoutAddressInput {
  create?: RestaurantCreateWithoutAddressInput;
  connect?: RestaurantWhereUniqueInput;
}

export interface RestaurantCreateWithoutAddressInput {
  id?: ID_Input;
  name: String;
  email: String;
  password: String;
  tel: String;
  image?: String;
  logo?: String;
  description?: String;
  status?: String;
  tags?: RestaurantCreatetagsInput;
  openingTimes?: OpeningTimeCreateManyWithoutRestaurantInput;
  averageBusyPreparationTime?: String;
  averagePreparationTime?: String;
  menus?: MenuCreateManyWithoutRestaurantInput;
  isConnected?: Boolean;
  stripe_user_id?: String;
  stripe_publishable_key?: String;
  access_token?: String;
  refresh_token?: String;
}

export interface RestaurantCreatetagsInput {
  set?: String[] | String;
}

export interface OpeningTimeCreateManyWithoutRestaurantInput {
  create?:
    | OpeningTimeCreateWithoutRestaurantInput[]
    | OpeningTimeCreateWithoutRestaurantInput;
  connect?: OpeningTimeWhereUniqueInput[] | OpeningTimeWhereUniqueInput;
}

export interface OpeningTimeCreateWithoutRestaurantInput {
  id?: ID_Input;
  hours?: OpeningTimeCreatehoursInput;
  days?: OpeningTimeCreatedaysInput;
}

export interface OpeningTimeCreatehoursInput {
  set?: String[] | String;
}

export interface OpeningTimeCreatedaysInput {
  set?: String[] | String;
}

export interface MenuCreateManyWithoutRestaurantInput {
  create?:
    | MenuCreateWithoutRestaurantInput[]
    | MenuCreateWithoutRestaurantInput;
  connect?: MenuWhereUniqueInput[] | MenuWhereUniqueInput;
}

export interface MenuCreateWithoutRestaurantInput {
  id?: ID_Input;
  name: String;
  description?: String;
  serviceTimes?: ServiceTimeCreateManyWithoutMenuInput;
  categories?: MenuCategoryCreateManyWithoutMenuInput;
}

export interface ServiceTimeCreateManyWithoutMenuInput {
  create?:
    | ServiceTimeCreateWithoutMenuInput[]
    | ServiceTimeCreateWithoutMenuInput;
  connect?: ServiceTimeWhereUniqueInput[] | ServiceTimeWhereUniqueInput;
}

export interface ServiceTimeCreateWithoutMenuInput {
  id?: ID_Input;
  hours?: ServiceTimeCreatehoursInput;
  days?: ServiceTimeCreatedaysInput;
}

export interface ServiceTimeCreatehoursInput {
  set?: String[] | String;
}

export interface ServiceTimeCreatedaysInput {
  set?: String[] | String;
}

export interface MenuCategoryCreateManyWithoutMenuInput {
  create?:
    | MenuCategoryCreateWithoutMenuInput[]
    | MenuCategoryCreateWithoutMenuInput;
  connect?: MenuCategoryWhereUniqueInput[] | MenuCategoryWhereUniqueInput;
}

export interface MenuCategoryCreateWithoutMenuInput {
  id?: ID_Input;
  name: String;
  description?: String;
  available?: Boolean;
  items?: MenuItemCreateManyWithoutCategoryInput;
}

export interface MenuItemCreateManyWithoutCategoryInput {
  create?:
    | MenuItemCreateWithoutCategoryInput[]
    | MenuItemCreateWithoutCategoryInput;
  connect?: MenuItemWhereUniqueInput[] | MenuItemWhereUniqueInput;
}

export interface MenuItemCreateWithoutCategoryInput {
  id?: ID_Input;
  name?: String;
  description?: String;
  price?: String;
  image?: String;
  available?: Boolean;
  dietary?: MenuItemCreatedietaryInput;
  options?: OptionCreateManyWithoutMenuItemsInput;
}

export interface MenuItemCreatedietaryInput {
  set?: String[] | String;
}

export interface OptionCreateManyWithoutMenuItemsInput {
  create?:
    | OptionCreateWithoutMenuItemsInput[]
    | OptionCreateWithoutMenuItemsInput;
  connect?: OptionWhereUniqueInput[] | OptionWhereUniqueInput;
}

export interface OptionCreateWithoutMenuItemsInput {
  id?: ID_Input;
  name: String;
  min: String;
  max: String;
  items?: OptionItemCreateManyWithoutOptionInput;
  restaurant?: RestaurantCreateOneInput;
}

export interface OptionItemCreateManyWithoutOptionInput {
  create?:
    | OptionItemCreateWithoutOptionInput[]
    | OptionItemCreateWithoutOptionInput;
  connect?: OptionItemWhereUniqueInput[] | OptionItemWhereUniqueInput;
}

export interface OptionItemCreateWithoutOptionInput {
  id?: ID_Input;
  name: String;
  price: String;
}

export interface RestaurantCreateOneInput {
  create?: RestaurantCreateInput;
  connect?: RestaurantWhereUniqueInput;
}

export interface RestaurantCreateInput {
  id?: ID_Input;
  name: String;
  email: String;
  password: String;
  address: AddressCreateOneWithoutRestaurantInput;
  tel: String;
  image?: String;
  logo?: String;
  description?: String;
  status?: String;
  tags?: RestaurantCreatetagsInput;
  openingTimes?: OpeningTimeCreateManyWithoutRestaurantInput;
  averageBusyPreparationTime?: String;
  averagePreparationTime?: String;
  menus?: MenuCreateManyWithoutRestaurantInput;
  isConnected?: Boolean;
  stripe_user_id?: String;
  stripe_publishable_key?: String;
  access_token?: String;
  refresh_token?: String;
}

export interface AddressCreateOneWithoutRestaurantInput {
  create?: AddressCreateWithoutRestaurantInput;
  connect?: AddressWhereUniqueInput;
}

export interface AddressCreateWithoutRestaurantInput {
  id?: ID_Input;
  number: String;
  streetName: String;
  city: String;
  postalCode: String;
}

export interface AddressUpdateInput {
  number?: String;
  streetName?: String;
  city?: String;
  postalCode?: String;
  restaurant?: RestaurantUpdateOneRequiredWithoutAddressInput;
}

export interface RestaurantUpdateOneRequiredWithoutAddressInput {
  create?: RestaurantCreateWithoutAddressInput;
  update?: RestaurantUpdateWithoutAddressDataInput;
  upsert?: RestaurantUpsertWithoutAddressInput;
  connect?: RestaurantWhereUniqueInput;
}

export interface RestaurantUpdateWithoutAddressDataInput {
  name?: String;
  email?: String;
  password?: String;
  tel?: String;
  image?: String;
  logo?: String;
  description?: String;
  status?: String;
  tags?: RestaurantUpdatetagsInput;
  openingTimes?: OpeningTimeUpdateManyWithoutRestaurantInput;
  averageBusyPreparationTime?: String;
  averagePreparationTime?: String;
  menus?: MenuUpdateManyWithoutRestaurantInput;
  isConnected?: Boolean;
  stripe_user_id?: String;
  stripe_publishable_key?: String;
  access_token?: String;
  refresh_token?: String;
}

export interface RestaurantUpdatetagsInput {
  set?: String[] | String;
}

export interface OpeningTimeUpdateManyWithoutRestaurantInput {
  create?:
    | OpeningTimeCreateWithoutRestaurantInput[]
    | OpeningTimeCreateWithoutRestaurantInput;
  delete?: OpeningTimeWhereUniqueInput[] | OpeningTimeWhereUniqueInput;
  connect?: OpeningTimeWhereUniqueInput[] | OpeningTimeWhereUniqueInput;
  set?: OpeningTimeWhereUniqueInput[] | OpeningTimeWhereUniqueInput;
  disconnect?: OpeningTimeWhereUniqueInput[] | OpeningTimeWhereUniqueInput;
  update?:
    | OpeningTimeUpdateWithWhereUniqueWithoutRestaurantInput[]
    | OpeningTimeUpdateWithWhereUniqueWithoutRestaurantInput;
  upsert?:
    | OpeningTimeUpsertWithWhereUniqueWithoutRestaurantInput[]
    | OpeningTimeUpsertWithWhereUniqueWithoutRestaurantInput;
  deleteMany?: OpeningTimeScalarWhereInput[] | OpeningTimeScalarWhereInput;
  updateMany?:
    | OpeningTimeUpdateManyWithWhereNestedInput[]
    | OpeningTimeUpdateManyWithWhereNestedInput;
}

export interface OpeningTimeUpdateWithWhereUniqueWithoutRestaurantInput {
  where: OpeningTimeWhereUniqueInput;
  data: OpeningTimeUpdateWithoutRestaurantDataInput;
}

export interface OpeningTimeUpdateWithoutRestaurantDataInput {
  hours?: OpeningTimeUpdatehoursInput;
  days?: OpeningTimeUpdatedaysInput;
}

export interface OpeningTimeUpdatehoursInput {
  set?: String[] | String;
}

export interface OpeningTimeUpdatedaysInput {
  set?: String[] | String;
}

export interface OpeningTimeUpsertWithWhereUniqueWithoutRestaurantInput {
  where: OpeningTimeWhereUniqueInput;
  update: OpeningTimeUpdateWithoutRestaurantDataInput;
  create: OpeningTimeCreateWithoutRestaurantInput;
}

export interface OpeningTimeScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: OpeningTimeScalarWhereInput[] | OpeningTimeScalarWhereInput;
  OR?: OpeningTimeScalarWhereInput[] | OpeningTimeScalarWhereInput;
  NOT?: OpeningTimeScalarWhereInput[] | OpeningTimeScalarWhereInput;
}

export interface OpeningTimeUpdateManyWithWhereNestedInput {
  where: OpeningTimeScalarWhereInput;
  data: OpeningTimeUpdateManyDataInput;
}

export interface OpeningTimeUpdateManyDataInput {
  hours?: OpeningTimeUpdatehoursInput;
  days?: OpeningTimeUpdatedaysInput;
}

export interface MenuUpdateManyWithoutRestaurantInput {
  create?:
    | MenuCreateWithoutRestaurantInput[]
    | MenuCreateWithoutRestaurantInput;
  delete?: MenuWhereUniqueInput[] | MenuWhereUniqueInput;
  connect?: MenuWhereUniqueInput[] | MenuWhereUniqueInput;
  set?: MenuWhereUniqueInput[] | MenuWhereUniqueInput;
  disconnect?: MenuWhereUniqueInput[] | MenuWhereUniqueInput;
  update?:
    | MenuUpdateWithWhereUniqueWithoutRestaurantInput[]
    | MenuUpdateWithWhereUniqueWithoutRestaurantInput;
  upsert?:
    | MenuUpsertWithWhereUniqueWithoutRestaurantInput[]
    | MenuUpsertWithWhereUniqueWithoutRestaurantInput;
  deleteMany?: MenuScalarWhereInput[] | MenuScalarWhereInput;
  updateMany?:
    | MenuUpdateManyWithWhereNestedInput[]
    | MenuUpdateManyWithWhereNestedInput;
}

export interface MenuUpdateWithWhereUniqueWithoutRestaurantInput {
  where: MenuWhereUniqueInput;
  data: MenuUpdateWithoutRestaurantDataInput;
}

export interface MenuUpdateWithoutRestaurantDataInput {
  name?: String;
  description?: String;
  serviceTimes?: ServiceTimeUpdateManyWithoutMenuInput;
  categories?: MenuCategoryUpdateManyWithoutMenuInput;
}

export interface ServiceTimeUpdateManyWithoutMenuInput {
  create?:
    | ServiceTimeCreateWithoutMenuInput[]
    | ServiceTimeCreateWithoutMenuInput;
  delete?: ServiceTimeWhereUniqueInput[] | ServiceTimeWhereUniqueInput;
  connect?: ServiceTimeWhereUniqueInput[] | ServiceTimeWhereUniqueInput;
  set?: ServiceTimeWhereUniqueInput[] | ServiceTimeWhereUniqueInput;
  disconnect?: ServiceTimeWhereUniqueInput[] | ServiceTimeWhereUniqueInput;
  update?:
    | ServiceTimeUpdateWithWhereUniqueWithoutMenuInput[]
    | ServiceTimeUpdateWithWhereUniqueWithoutMenuInput;
  upsert?:
    | ServiceTimeUpsertWithWhereUniqueWithoutMenuInput[]
    | ServiceTimeUpsertWithWhereUniqueWithoutMenuInput;
  deleteMany?: ServiceTimeScalarWhereInput[] | ServiceTimeScalarWhereInput;
  updateMany?:
    | ServiceTimeUpdateManyWithWhereNestedInput[]
    | ServiceTimeUpdateManyWithWhereNestedInput;
}

export interface ServiceTimeUpdateWithWhereUniqueWithoutMenuInput {
  where: ServiceTimeWhereUniqueInput;
  data: ServiceTimeUpdateWithoutMenuDataInput;
}

export interface ServiceTimeUpdateWithoutMenuDataInput {
  hours?: ServiceTimeUpdatehoursInput;
  days?: ServiceTimeUpdatedaysInput;
}

export interface ServiceTimeUpdatehoursInput {
  set?: String[] | String;
}

export interface ServiceTimeUpdatedaysInput {
  set?: String[] | String;
}

export interface ServiceTimeUpsertWithWhereUniqueWithoutMenuInput {
  where: ServiceTimeWhereUniqueInput;
  update: ServiceTimeUpdateWithoutMenuDataInput;
  create: ServiceTimeCreateWithoutMenuInput;
}

export interface ServiceTimeScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: ServiceTimeScalarWhereInput[] | ServiceTimeScalarWhereInput;
  OR?: ServiceTimeScalarWhereInput[] | ServiceTimeScalarWhereInput;
  NOT?: ServiceTimeScalarWhereInput[] | ServiceTimeScalarWhereInput;
}

export interface ServiceTimeUpdateManyWithWhereNestedInput {
  where: ServiceTimeScalarWhereInput;
  data: ServiceTimeUpdateManyDataInput;
}

export interface ServiceTimeUpdateManyDataInput {
  hours?: ServiceTimeUpdatehoursInput;
  days?: ServiceTimeUpdatedaysInput;
}

export interface MenuCategoryUpdateManyWithoutMenuInput {
  create?:
    | MenuCategoryCreateWithoutMenuInput[]
    | MenuCategoryCreateWithoutMenuInput;
  delete?: MenuCategoryWhereUniqueInput[] | MenuCategoryWhereUniqueInput;
  connect?: MenuCategoryWhereUniqueInput[] | MenuCategoryWhereUniqueInput;
  set?: MenuCategoryWhereUniqueInput[] | MenuCategoryWhereUniqueInput;
  disconnect?: MenuCategoryWhereUniqueInput[] | MenuCategoryWhereUniqueInput;
  update?:
    | MenuCategoryUpdateWithWhereUniqueWithoutMenuInput[]
    | MenuCategoryUpdateWithWhereUniqueWithoutMenuInput;
  upsert?:
    | MenuCategoryUpsertWithWhereUniqueWithoutMenuInput[]
    | MenuCategoryUpsertWithWhereUniqueWithoutMenuInput;
  deleteMany?: MenuCategoryScalarWhereInput[] | MenuCategoryScalarWhereInput;
  updateMany?:
    | MenuCategoryUpdateManyWithWhereNestedInput[]
    | MenuCategoryUpdateManyWithWhereNestedInput;
}

export interface MenuCategoryUpdateWithWhereUniqueWithoutMenuInput {
  where: MenuCategoryWhereUniqueInput;
  data: MenuCategoryUpdateWithoutMenuDataInput;
}

export interface MenuCategoryUpdateWithoutMenuDataInput {
  name?: String;
  description?: String;
  available?: Boolean;
  items?: MenuItemUpdateManyWithoutCategoryInput;
}

export interface MenuItemUpdateManyWithoutCategoryInput {
  create?:
    | MenuItemCreateWithoutCategoryInput[]
    | MenuItemCreateWithoutCategoryInput;
  delete?: MenuItemWhereUniqueInput[] | MenuItemWhereUniqueInput;
  connect?: MenuItemWhereUniqueInput[] | MenuItemWhereUniqueInput;
  set?: MenuItemWhereUniqueInput[] | MenuItemWhereUniqueInput;
  disconnect?: MenuItemWhereUniqueInput[] | MenuItemWhereUniqueInput;
  update?:
    | MenuItemUpdateWithWhereUniqueWithoutCategoryInput[]
    | MenuItemUpdateWithWhereUniqueWithoutCategoryInput;
  upsert?:
    | MenuItemUpsertWithWhereUniqueWithoutCategoryInput[]
    | MenuItemUpsertWithWhereUniqueWithoutCategoryInput;
  deleteMany?: MenuItemScalarWhereInput[] | MenuItemScalarWhereInput;
  updateMany?:
    | MenuItemUpdateManyWithWhereNestedInput[]
    | MenuItemUpdateManyWithWhereNestedInput;
}

export interface MenuItemUpdateWithWhereUniqueWithoutCategoryInput {
  where: MenuItemWhereUniqueInput;
  data: MenuItemUpdateWithoutCategoryDataInput;
}

export interface MenuItemUpdateWithoutCategoryDataInput {
  name?: String;
  description?: String;
  price?: String;
  image?: String;
  available?: Boolean;
  dietary?: MenuItemUpdatedietaryInput;
  options?: OptionUpdateManyWithoutMenuItemsInput;
}

export interface MenuItemUpdatedietaryInput {
  set?: String[] | String;
}

export interface OptionUpdateManyWithoutMenuItemsInput {
  create?:
    | OptionCreateWithoutMenuItemsInput[]
    | OptionCreateWithoutMenuItemsInput;
  delete?: OptionWhereUniqueInput[] | OptionWhereUniqueInput;
  connect?: OptionWhereUniqueInput[] | OptionWhereUniqueInput;
  set?: OptionWhereUniqueInput[] | OptionWhereUniqueInput;
  disconnect?: OptionWhereUniqueInput[] | OptionWhereUniqueInput;
  update?:
    | OptionUpdateWithWhereUniqueWithoutMenuItemsInput[]
    | OptionUpdateWithWhereUniqueWithoutMenuItemsInput;
  upsert?:
    | OptionUpsertWithWhereUniqueWithoutMenuItemsInput[]
    | OptionUpsertWithWhereUniqueWithoutMenuItemsInput;
  deleteMany?: OptionScalarWhereInput[] | OptionScalarWhereInput;
  updateMany?:
    | OptionUpdateManyWithWhereNestedInput[]
    | OptionUpdateManyWithWhereNestedInput;
}

export interface OptionUpdateWithWhereUniqueWithoutMenuItemsInput {
  where: OptionWhereUniqueInput;
  data: OptionUpdateWithoutMenuItemsDataInput;
}

export interface OptionUpdateWithoutMenuItemsDataInput {
  name?: String;
  min?: String;
  max?: String;
  items?: OptionItemUpdateManyWithoutOptionInput;
  restaurant?: RestaurantUpdateOneInput;
}

export interface OptionItemUpdateManyWithoutOptionInput {
  create?:
    | OptionItemCreateWithoutOptionInput[]
    | OptionItemCreateWithoutOptionInput;
  delete?: OptionItemWhereUniqueInput[] | OptionItemWhereUniqueInput;
  connect?: OptionItemWhereUniqueInput[] | OptionItemWhereUniqueInput;
  set?: OptionItemWhereUniqueInput[] | OptionItemWhereUniqueInput;
  disconnect?: OptionItemWhereUniqueInput[] | OptionItemWhereUniqueInput;
  update?:
    | OptionItemUpdateWithWhereUniqueWithoutOptionInput[]
    | OptionItemUpdateWithWhereUniqueWithoutOptionInput;
  upsert?:
    | OptionItemUpsertWithWhereUniqueWithoutOptionInput[]
    | OptionItemUpsertWithWhereUniqueWithoutOptionInput;
  deleteMany?: OptionItemScalarWhereInput[] | OptionItemScalarWhereInput;
  updateMany?:
    | OptionItemUpdateManyWithWhereNestedInput[]
    | OptionItemUpdateManyWithWhereNestedInput;
}

export interface OptionItemUpdateWithWhereUniqueWithoutOptionInput {
  where: OptionItemWhereUniqueInput;
  data: OptionItemUpdateWithoutOptionDataInput;
}

export interface OptionItemUpdateWithoutOptionDataInput {
  name?: String;
  price?: String;
}

export interface OptionItemUpsertWithWhereUniqueWithoutOptionInput {
  where: OptionItemWhereUniqueInput;
  update: OptionItemUpdateWithoutOptionDataInput;
  create: OptionItemCreateWithoutOptionInput;
}

export interface OptionItemScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  price?: String;
  price_not?: String;
  price_in?: String[] | String;
  price_not_in?: String[] | String;
  price_lt?: String;
  price_lte?: String;
  price_gt?: String;
  price_gte?: String;
  price_contains?: String;
  price_not_contains?: String;
  price_starts_with?: String;
  price_not_starts_with?: String;
  price_ends_with?: String;
  price_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: OptionItemScalarWhereInput[] | OptionItemScalarWhereInput;
  OR?: OptionItemScalarWhereInput[] | OptionItemScalarWhereInput;
  NOT?: OptionItemScalarWhereInput[] | OptionItemScalarWhereInput;
}

export interface OptionItemUpdateManyWithWhereNestedInput {
  where: OptionItemScalarWhereInput;
  data: OptionItemUpdateManyDataInput;
}

export interface OptionItemUpdateManyDataInput {
  name?: String;
  price?: String;
}

export interface RestaurantUpdateOneInput {
  create?: RestaurantCreateInput;
  update?: RestaurantUpdateDataInput;
  upsert?: RestaurantUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: RestaurantWhereUniqueInput;
}

export interface RestaurantUpdateDataInput {
  name?: String;
  email?: String;
  password?: String;
  address?: AddressUpdateOneRequiredWithoutRestaurantInput;
  tel?: String;
  image?: String;
  logo?: String;
  description?: String;
  status?: String;
  tags?: RestaurantUpdatetagsInput;
  openingTimes?: OpeningTimeUpdateManyWithoutRestaurantInput;
  averageBusyPreparationTime?: String;
  averagePreparationTime?: String;
  menus?: MenuUpdateManyWithoutRestaurantInput;
  isConnected?: Boolean;
  stripe_user_id?: String;
  stripe_publishable_key?: String;
  access_token?: String;
  refresh_token?: String;
}

export interface AddressUpdateOneRequiredWithoutRestaurantInput {
  create?: AddressCreateWithoutRestaurantInput;
  update?: AddressUpdateWithoutRestaurantDataInput;
  upsert?: AddressUpsertWithoutRestaurantInput;
  connect?: AddressWhereUniqueInput;
}

export interface AddressUpdateWithoutRestaurantDataInput {
  number?: String;
  streetName?: String;
  city?: String;
  postalCode?: String;
}

export interface AddressUpsertWithoutRestaurantInput {
  update: AddressUpdateWithoutRestaurantDataInput;
  create: AddressCreateWithoutRestaurantInput;
}

export interface RestaurantUpsertNestedInput {
  update: RestaurantUpdateDataInput;
  create: RestaurantCreateInput;
}

export interface OptionUpsertWithWhereUniqueWithoutMenuItemsInput {
  where: OptionWhereUniqueInput;
  update: OptionUpdateWithoutMenuItemsDataInput;
  create: OptionCreateWithoutMenuItemsInput;
}

export interface OptionScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  min?: String;
  min_not?: String;
  min_in?: String[] | String;
  min_not_in?: String[] | String;
  min_lt?: String;
  min_lte?: String;
  min_gt?: String;
  min_gte?: String;
  min_contains?: String;
  min_not_contains?: String;
  min_starts_with?: String;
  min_not_starts_with?: String;
  min_ends_with?: String;
  min_not_ends_with?: String;
  max?: String;
  max_not?: String;
  max_in?: String[] | String;
  max_not_in?: String[] | String;
  max_lt?: String;
  max_lte?: String;
  max_gt?: String;
  max_gte?: String;
  max_contains?: String;
  max_not_contains?: String;
  max_starts_with?: String;
  max_not_starts_with?: String;
  max_ends_with?: String;
  max_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: OptionScalarWhereInput[] | OptionScalarWhereInput;
  OR?: OptionScalarWhereInput[] | OptionScalarWhereInput;
  NOT?: OptionScalarWhereInput[] | OptionScalarWhereInput;
}

export interface OptionUpdateManyWithWhereNestedInput {
  where: OptionScalarWhereInput;
  data: OptionUpdateManyDataInput;
}

export interface OptionUpdateManyDataInput {
  name?: String;
  min?: String;
  max?: String;
}

export interface MenuItemUpsertWithWhereUniqueWithoutCategoryInput {
  where: MenuItemWhereUniqueInput;
  update: MenuItemUpdateWithoutCategoryDataInput;
  create: MenuItemCreateWithoutCategoryInput;
}

export interface MenuItemScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  price?: String;
  price_not?: String;
  price_in?: String[] | String;
  price_not_in?: String[] | String;
  price_lt?: String;
  price_lte?: String;
  price_gt?: String;
  price_gte?: String;
  price_contains?: String;
  price_not_contains?: String;
  price_starts_with?: String;
  price_not_starts_with?: String;
  price_ends_with?: String;
  price_not_ends_with?: String;
  image?: String;
  image_not?: String;
  image_in?: String[] | String;
  image_not_in?: String[] | String;
  image_lt?: String;
  image_lte?: String;
  image_gt?: String;
  image_gte?: String;
  image_contains?: String;
  image_not_contains?: String;
  image_starts_with?: String;
  image_not_starts_with?: String;
  image_ends_with?: String;
  image_not_ends_with?: String;
  available?: Boolean;
  available_not?: Boolean;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: MenuItemScalarWhereInput[] | MenuItemScalarWhereInput;
  OR?: MenuItemScalarWhereInput[] | MenuItemScalarWhereInput;
  NOT?: MenuItemScalarWhereInput[] | MenuItemScalarWhereInput;
}

export interface MenuItemUpdateManyWithWhereNestedInput {
  where: MenuItemScalarWhereInput;
  data: MenuItemUpdateManyDataInput;
}

export interface MenuItemUpdateManyDataInput {
  name?: String;
  description?: String;
  price?: String;
  image?: String;
  available?: Boolean;
  dietary?: MenuItemUpdatedietaryInput;
}

export interface MenuCategoryUpsertWithWhereUniqueWithoutMenuInput {
  where: MenuCategoryWhereUniqueInput;
  update: MenuCategoryUpdateWithoutMenuDataInput;
  create: MenuCategoryCreateWithoutMenuInput;
}

export interface MenuCategoryScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  available?: Boolean;
  available_not?: Boolean;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: MenuCategoryScalarWhereInput[] | MenuCategoryScalarWhereInput;
  OR?: MenuCategoryScalarWhereInput[] | MenuCategoryScalarWhereInput;
  NOT?: MenuCategoryScalarWhereInput[] | MenuCategoryScalarWhereInput;
}

export interface MenuCategoryUpdateManyWithWhereNestedInput {
  where: MenuCategoryScalarWhereInput;
  data: MenuCategoryUpdateManyDataInput;
}

export interface MenuCategoryUpdateManyDataInput {
  name?: String;
  description?: String;
  available?: Boolean;
}

export interface MenuUpsertWithWhereUniqueWithoutRestaurantInput {
  where: MenuWhereUniqueInput;
  update: MenuUpdateWithoutRestaurantDataInput;
  create: MenuCreateWithoutRestaurantInput;
}

export interface MenuScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: MenuScalarWhereInput[] | MenuScalarWhereInput;
  OR?: MenuScalarWhereInput[] | MenuScalarWhereInput;
  NOT?: MenuScalarWhereInput[] | MenuScalarWhereInput;
}

export interface MenuUpdateManyWithWhereNestedInput {
  where: MenuScalarWhereInput;
  data: MenuUpdateManyDataInput;
}

export interface MenuUpdateManyDataInput {
  name?: String;
  description?: String;
}

export interface RestaurantUpsertWithoutAddressInput {
  update: RestaurantUpdateWithoutAddressDataInput;
  create: RestaurantCreateWithoutAddressInput;
}

export interface AddressUpdateManyMutationInput {
  number?: String;
  streetName?: String;
  city?: String;
  postalCode?: String;
}

export interface CustomerCreateInput {
  id?: ID_Input;
  email: String;
  password: String;
  name: String;
  tel: String;
  customerStripeId?: String;
  orders?: OrderCreateManyWithoutCustomerInput;
  paymentMethod?: PaymentMethodCreateOneWithoutCustomerInput;
}

export interface OrderCreateManyWithoutCustomerInput {
  create?: OrderCreateWithoutCustomerInput[] | OrderCreateWithoutCustomerInput;
  connect?: OrderWhereUniqueInput[] | OrderWhereUniqueInput;
}

export interface OrderCreateWithoutCustomerInput {
  id?: ID_Input;
  orderNo: Int;
  paymentIntentId?: String;
  status?: String;
  dueAt: DateTimeInput;
  delayedBy?: Int;
  restaurant: RestaurantCreateOneInput;
  items?: OrderItemCreateManyWithoutOrderInput;
  total: String;
  priceAdjustment?: String;
  cancelReason?: String;
  priceAdjustmentReason?: String;
}

export interface OrderItemCreateManyWithoutOrderInput {
  create?:
    | OrderItemCreateWithoutOrderInput[]
    | OrderItemCreateWithoutOrderInput;
  connect?: OrderItemWhereUniqueInput[] | OrderItemWhereUniqueInput;
}

export interface OrderItemCreateWithoutOrderInput {
  id?: ID_Input;
  name: String;
  price?: String;
  image?: String;
  quantity?: Int;
  options?: OrderItemOptionCreateManyWithoutOrderItemInput;
}

export interface OrderItemOptionCreateManyWithoutOrderItemInput {
  create?:
    | OrderItemOptionCreateWithoutOrderItemInput[]
    | OrderItemOptionCreateWithoutOrderItemInput;
  connect?: OrderItemOptionWhereUniqueInput[] | OrderItemOptionWhereUniqueInput;
}

export interface OrderItemOptionCreateWithoutOrderItemInput {
  id?: ID_Input;
  name: String;
  items?: OrderItemOptionItemCreateManyWithoutOptionInput;
}

export interface OrderItemOptionItemCreateManyWithoutOptionInput {
  create?:
    | OrderItemOptionItemCreateWithoutOptionInput[]
    | OrderItemOptionItemCreateWithoutOptionInput;
  connect?:
    | OrderItemOptionItemWhereUniqueInput[]
    | OrderItemOptionItemWhereUniqueInput;
}

export interface OrderItemOptionItemCreateWithoutOptionInput {
  id?: ID_Input;
  name: String;
  price: String;
}

export interface PaymentMethodCreateOneWithoutCustomerInput {
  create?: PaymentMethodCreateWithoutCustomerInput;
  connect?: PaymentMethodWhereUniqueInput;
}

export interface PaymentMethodCreateWithoutCustomerInput {
  id?: ID_Input;
  payment_method_id: String;
  brand: String;
  last4: String;
}

export interface CustomerUpdateInput {
  email?: String;
  password?: String;
  name?: String;
  tel?: String;
  customerStripeId?: String;
  orders?: OrderUpdateManyWithoutCustomerInput;
  paymentMethod?: PaymentMethodUpdateOneWithoutCustomerInput;
}

export interface OrderUpdateManyWithoutCustomerInput {
  create?: OrderCreateWithoutCustomerInput[] | OrderCreateWithoutCustomerInput;
  delete?: OrderWhereUniqueInput[] | OrderWhereUniqueInput;
  connect?: OrderWhereUniqueInput[] | OrderWhereUniqueInput;
  set?: OrderWhereUniqueInput[] | OrderWhereUniqueInput;
  disconnect?: OrderWhereUniqueInput[] | OrderWhereUniqueInput;
  update?:
    | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    | OrderUpdateWithWhereUniqueWithoutCustomerInput;
  upsert?:
    | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    | OrderUpsertWithWhereUniqueWithoutCustomerInput;
  deleteMany?: OrderScalarWhereInput[] | OrderScalarWhereInput;
  updateMany?:
    | OrderUpdateManyWithWhereNestedInput[]
    | OrderUpdateManyWithWhereNestedInput;
}

export interface OrderUpdateWithWhereUniqueWithoutCustomerInput {
  where: OrderWhereUniqueInput;
  data: OrderUpdateWithoutCustomerDataInput;
}

export interface OrderUpdateWithoutCustomerDataInput {
  orderNo?: Int;
  paymentIntentId?: String;
  status?: String;
  dueAt?: DateTimeInput;
  delayedBy?: Int;
  restaurant?: RestaurantUpdateOneRequiredInput;
  items?: OrderItemUpdateManyWithoutOrderInput;
  total?: String;
  priceAdjustment?: String;
  cancelReason?: String;
  priceAdjustmentReason?: String;
}

export interface RestaurantUpdateOneRequiredInput {
  create?: RestaurantCreateInput;
  update?: RestaurantUpdateDataInput;
  upsert?: RestaurantUpsertNestedInput;
  connect?: RestaurantWhereUniqueInput;
}

export interface OrderItemUpdateManyWithoutOrderInput {
  create?:
    | OrderItemCreateWithoutOrderInput[]
    | OrderItemCreateWithoutOrderInput;
  delete?: OrderItemWhereUniqueInput[] | OrderItemWhereUniqueInput;
  connect?: OrderItemWhereUniqueInput[] | OrderItemWhereUniqueInput;
  set?: OrderItemWhereUniqueInput[] | OrderItemWhereUniqueInput;
  disconnect?: OrderItemWhereUniqueInput[] | OrderItemWhereUniqueInput;
  update?:
    | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    | OrderItemUpdateWithWhereUniqueWithoutOrderInput;
  upsert?:
    | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    | OrderItemUpsertWithWhereUniqueWithoutOrderInput;
  deleteMany?: OrderItemScalarWhereInput[] | OrderItemScalarWhereInput;
  updateMany?:
    | OrderItemUpdateManyWithWhereNestedInput[]
    | OrderItemUpdateManyWithWhereNestedInput;
}

export interface OrderItemUpdateWithWhereUniqueWithoutOrderInput {
  where: OrderItemWhereUniqueInput;
  data: OrderItemUpdateWithoutOrderDataInput;
}

export interface OrderItemUpdateWithoutOrderDataInput {
  name?: String;
  price?: String;
  image?: String;
  quantity?: Int;
  options?: OrderItemOptionUpdateManyWithoutOrderItemInput;
}

export interface OrderItemOptionUpdateManyWithoutOrderItemInput {
  create?:
    | OrderItemOptionCreateWithoutOrderItemInput[]
    | OrderItemOptionCreateWithoutOrderItemInput;
  delete?: OrderItemOptionWhereUniqueInput[] | OrderItemOptionWhereUniqueInput;
  connect?: OrderItemOptionWhereUniqueInput[] | OrderItemOptionWhereUniqueInput;
  set?: OrderItemOptionWhereUniqueInput[] | OrderItemOptionWhereUniqueInput;
  disconnect?:
    | OrderItemOptionWhereUniqueInput[]
    | OrderItemOptionWhereUniqueInput;
  update?:
    | OrderItemOptionUpdateWithWhereUniqueWithoutOrderItemInput[]
    | OrderItemOptionUpdateWithWhereUniqueWithoutOrderItemInput;
  upsert?:
    | OrderItemOptionUpsertWithWhereUniqueWithoutOrderItemInput[]
    | OrderItemOptionUpsertWithWhereUniqueWithoutOrderItemInput;
  deleteMany?:
    | OrderItemOptionScalarWhereInput[]
    | OrderItemOptionScalarWhereInput;
  updateMany?:
    | OrderItemOptionUpdateManyWithWhereNestedInput[]
    | OrderItemOptionUpdateManyWithWhereNestedInput;
}

export interface OrderItemOptionUpdateWithWhereUniqueWithoutOrderItemInput {
  where: OrderItemOptionWhereUniqueInput;
  data: OrderItemOptionUpdateWithoutOrderItemDataInput;
}

export interface OrderItemOptionUpdateWithoutOrderItemDataInput {
  name?: String;
  items?: OrderItemOptionItemUpdateManyWithoutOptionInput;
}

export interface OrderItemOptionItemUpdateManyWithoutOptionInput {
  create?:
    | OrderItemOptionItemCreateWithoutOptionInput[]
    | OrderItemOptionItemCreateWithoutOptionInput;
  delete?:
    | OrderItemOptionItemWhereUniqueInput[]
    | OrderItemOptionItemWhereUniqueInput;
  connect?:
    | OrderItemOptionItemWhereUniqueInput[]
    | OrderItemOptionItemWhereUniqueInput;
  set?:
    | OrderItemOptionItemWhereUniqueInput[]
    | OrderItemOptionItemWhereUniqueInput;
  disconnect?:
    | OrderItemOptionItemWhereUniqueInput[]
    | OrderItemOptionItemWhereUniqueInput;
  update?:
    | OrderItemOptionItemUpdateWithWhereUniqueWithoutOptionInput[]
    | OrderItemOptionItemUpdateWithWhereUniqueWithoutOptionInput;
  upsert?:
    | OrderItemOptionItemUpsertWithWhereUniqueWithoutOptionInput[]
    | OrderItemOptionItemUpsertWithWhereUniqueWithoutOptionInput;
  deleteMany?:
    | OrderItemOptionItemScalarWhereInput[]
    | OrderItemOptionItemScalarWhereInput;
  updateMany?:
    | OrderItemOptionItemUpdateManyWithWhereNestedInput[]
    | OrderItemOptionItemUpdateManyWithWhereNestedInput;
}

export interface OrderItemOptionItemUpdateWithWhereUniqueWithoutOptionInput {
  where: OrderItemOptionItemWhereUniqueInput;
  data: OrderItemOptionItemUpdateWithoutOptionDataInput;
}

export interface OrderItemOptionItemUpdateWithoutOptionDataInput {
  name?: String;
  price?: String;
}

export interface OrderItemOptionItemUpsertWithWhereUniqueWithoutOptionInput {
  where: OrderItemOptionItemWhereUniqueInput;
  update: OrderItemOptionItemUpdateWithoutOptionDataInput;
  create: OrderItemOptionItemCreateWithoutOptionInput;
}

export interface OrderItemOptionItemScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  price?: String;
  price_not?: String;
  price_in?: String[] | String;
  price_not_in?: String[] | String;
  price_lt?: String;
  price_lte?: String;
  price_gt?: String;
  price_gte?: String;
  price_contains?: String;
  price_not_contains?: String;
  price_starts_with?: String;
  price_not_starts_with?: String;
  price_ends_with?: String;
  price_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?:
    | OrderItemOptionItemScalarWhereInput[]
    | OrderItemOptionItemScalarWhereInput;
  OR?:
    | OrderItemOptionItemScalarWhereInput[]
    | OrderItemOptionItemScalarWhereInput;
  NOT?:
    | OrderItemOptionItemScalarWhereInput[]
    | OrderItemOptionItemScalarWhereInput;
}

export interface OrderItemOptionItemUpdateManyWithWhereNestedInput {
  where: OrderItemOptionItemScalarWhereInput;
  data: OrderItemOptionItemUpdateManyDataInput;
}

export interface OrderItemOptionItemUpdateManyDataInput {
  name?: String;
  price?: String;
}

export interface OrderItemOptionUpsertWithWhereUniqueWithoutOrderItemInput {
  where: OrderItemOptionWhereUniqueInput;
  update: OrderItemOptionUpdateWithoutOrderItemDataInput;
  create: OrderItemOptionCreateWithoutOrderItemInput;
}

export interface OrderItemOptionScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: OrderItemOptionScalarWhereInput[] | OrderItemOptionScalarWhereInput;
  OR?: OrderItemOptionScalarWhereInput[] | OrderItemOptionScalarWhereInput;
  NOT?: OrderItemOptionScalarWhereInput[] | OrderItemOptionScalarWhereInput;
}

export interface OrderItemOptionUpdateManyWithWhereNestedInput {
  where: OrderItemOptionScalarWhereInput;
  data: OrderItemOptionUpdateManyDataInput;
}

export interface OrderItemOptionUpdateManyDataInput {
  name?: String;
}

export interface OrderItemUpsertWithWhereUniqueWithoutOrderInput {
  where: OrderItemWhereUniqueInput;
  update: OrderItemUpdateWithoutOrderDataInput;
  create: OrderItemCreateWithoutOrderInput;
}

export interface OrderItemScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  price?: String;
  price_not?: String;
  price_in?: String[] | String;
  price_not_in?: String[] | String;
  price_lt?: String;
  price_lte?: String;
  price_gt?: String;
  price_gte?: String;
  price_contains?: String;
  price_not_contains?: String;
  price_starts_with?: String;
  price_not_starts_with?: String;
  price_ends_with?: String;
  price_not_ends_with?: String;
  image?: String;
  image_not?: String;
  image_in?: String[] | String;
  image_not_in?: String[] | String;
  image_lt?: String;
  image_lte?: String;
  image_gt?: String;
  image_gte?: String;
  image_contains?: String;
  image_not_contains?: String;
  image_starts_with?: String;
  image_not_starts_with?: String;
  image_ends_with?: String;
  image_not_ends_with?: String;
  quantity?: Int;
  quantity_not?: Int;
  quantity_in?: Int[] | Int;
  quantity_not_in?: Int[] | Int;
  quantity_lt?: Int;
  quantity_lte?: Int;
  quantity_gt?: Int;
  quantity_gte?: Int;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: OrderItemScalarWhereInput[] | OrderItemScalarWhereInput;
  OR?: OrderItemScalarWhereInput[] | OrderItemScalarWhereInput;
  NOT?: OrderItemScalarWhereInput[] | OrderItemScalarWhereInput;
}

export interface OrderItemUpdateManyWithWhereNestedInput {
  where: OrderItemScalarWhereInput;
  data: OrderItemUpdateManyDataInput;
}

export interface OrderItemUpdateManyDataInput {
  name?: String;
  price?: String;
  image?: String;
  quantity?: Int;
}

export interface OrderUpsertWithWhereUniqueWithoutCustomerInput {
  where: OrderWhereUniqueInput;
  update: OrderUpdateWithoutCustomerDataInput;
  create: OrderCreateWithoutCustomerInput;
}

export interface OrderScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  orderNo?: Int;
  orderNo_not?: Int;
  orderNo_in?: Int[] | Int;
  orderNo_not_in?: Int[] | Int;
  orderNo_lt?: Int;
  orderNo_lte?: Int;
  orderNo_gt?: Int;
  orderNo_gte?: Int;
  paymentIntentId?: String;
  paymentIntentId_not?: String;
  paymentIntentId_in?: String[] | String;
  paymentIntentId_not_in?: String[] | String;
  paymentIntentId_lt?: String;
  paymentIntentId_lte?: String;
  paymentIntentId_gt?: String;
  paymentIntentId_gte?: String;
  paymentIntentId_contains?: String;
  paymentIntentId_not_contains?: String;
  paymentIntentId_starts_with?: String;
  paymentIntentId_not_starts_with?: String;
  paymentIntentId_ends_with?: String;
  paymentIntentId_not_ends_with?: String;
  status?: String;
  status_not?: String;
  status_in?: String[] | String;
  status_not_in?: String[] | String;
  status_lt?: String;
  status_lte?: String;
  status_gt?: String;
  status_gte?: String;
  status_contains?: String;
  status_not_contains?: String;
  status_starts_with?: String;
  status_not_starts_with?: String;
  status_ends_with?: String;
  status_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  dueAt?: DateTimeInput;
  dueAt_not?: DateTimeInput;
  dueAt_in?: DateTimeInput[] | DateTimeInput;
  dueAt_not_in?: DateTimeInput[] | DateTimeInput;
  dueAt_lt?: DateTimeInput;
  dueAt_lte?: DateTimeInput;
  dueAt_gt?: DateTimeInput;
  dueAt_gte?: DateTimeInput;
  delayedBy?: Int;
  delayedBy_not?: Int;
  delayedBy_in?: Int[] | Int;
  delayedBy_not_in?: Int[] | Int;
  delayedBy_lt?: Int;
  delayedBy_lte?: Int;
  delayedBy_gt?: Int;
  delayedBy_gte?: Int;
  total?: String;
  total_not?: String;
  total_in?: String[] | String;
  total_not_in?: String[] | String;
  total_lt?: String;
  total_lte?: String;
  total_gt?: String;
  total_gte?: String;
  total_contains?: String;
  total_not_contains?: String;
  total_starts_with?: String;
  total_not_starts_with?: String;
  total_ends_with?: String;
  total_not_ends_with?: String;
  priceAdjustment?: String;
  priceAdjustment_not?: String;
  priceAdjustment_in?: String[] | String;
  priceAdjustment_not_in?: String[] | String;
  priceAdjustment_lt?: String;
  priceAdjustment_lte?: String;
  priceAdjustment_gt?: String;
  priceAdjustment_gte?: String;
  priceAdjustment_contains?: String;
  priceAdjustment_not_contains?: String;
  priceAdjustment_starts_with?: String;
  priceAdjustment_not_starts_with?: String;
  priceAdjustment_ends_with?: String;
  priceAdjustment_not_ends_with?: String;
  cancelReason?: String;
  cancelReason_not?: String;
  cancelReason_in?: String[] | String;
  cancelReason_not_in?: String[] | String;
  cancelReason_lt?: String;
  cancelReason_lte?: String;
  cancelReason_gt?: String;
  cancelReason_gte?: String;
  cancelReason_contains?: String;
  cancelReason_not_contains?: String;
  cancelReason_starts_with?: String;
  cancelReason_not_starts_with?: String;
  cancelReason_ends_with?: String;
  cancelReason_not_ends_with?: String;
  priceAdjustmentReason?: String;
  priceAdjustmentReason_not?: String;
  priceAdjustmentReason_in?: String[] | String;
  priceAdjustmentReason_not_in?: String[] | String;
  priceAdjustmentReason_lt?: String;
  priceAdjustmentReason_lte?: String;
  priceAdjustmentReason_gt?: String;
  priceAdjustmentReason_gte?: String;
  priceAdjustmentReason_contains?: String;
  priceAdjustmentReason_not_contains?: String;
  priceAdjustmentReason_starts_with?: String;
  priceAdjustmentReason_not_starts_with?: String;
  priceAdjustmentReason_ends_with?: String;
  priceAdjustmentReason_not_ends_with?: String;
  AND?: OrderScalarWhereInput[] | OrderScalarWhereInput;
  OR?: OrderScalarWhereInput[] | OrderScalarWhereInput;
  NOT?: OrderScalarWhereInput[] | OrderScalarWhereInput;
}

export interface OrderUpdateManyWithWhereNestedInput {
  where: OrderScalarWhereInput;
  data: OrderUpdateManyDataInput;
}

export interface OrderUpdateManyDataInput {
  orderNo?: Int;
  paymentIntentId?: String;
  status?: String;
  dueAt?: DateTimeInput;
  delayedBy?: Int;
  total?: String;
  priceAdjustment?: String;
  cancelReason?: String;
  priceAdjustmentReason?: String;
}

export interface PaymentMethodUpdateOneWithoutCustomerInput {
  create?: PaymentMethodCreateWithoutCustomerInput;
  update?: PaymentMethodUpdateWithoutCustomerDataInput;
  upsert?: PaymentMethodUpsertWithoutCustomerInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PaymentMethodWhereUniqueInput;
}

export interface PaymentMethodUpdateWithoutCustomerDataInput {
  payment_method_id?: String;
  brand?: String;
  last4?: String;
}

export interface PaymentMethodUpsertWithoutCustomerInput {
  update: PaymentMethodUpdateWithoutCustomerDataInput;
  create: PaymentMethodCreateWithoutCustomerInput;
}

export interface CustomerUpdateManyMutationInput {
  email?: String;
  password?: String;
  name?: String;
  tel?: String;
  customerStripeId?: String;
}

export interface MenuCreateInput {
  id?: ID_Input;
  name: String;
  description?: String;
  restaurant: RestaurantCreateOneWithoutMenusInput;
  serviceTimes?: ServiceTimeCreateManyWithoutMenuInput;
  categories?: MenuCategoryCreateManyWithoutMenuInput;
}

export interface RestaurantCreateOneWithoutMenusInput {
  create?: RestaurantCreateWithoutMenusInput;
  connect?: RestaurantWhereUniqueInput;
}

export interface RestaurantCreateWithoutMenusInput {
  id?: ID_Input;
  name: String;
  email: String;
  password: String;
  address: AddressCreateOneWithoutRestaurantInput;
  tel: String;
  image?: String;
  logo?: String;
  description?: String;
  status?: String;
  tags?: RestaurantCreatetagsInput;
  openingTimes?: OpeningTimeCreateManyWithoutRestaurantInput;
  averageBusyPreparationTime?: String;
  averagePreparationTime?: String;
  isConnected?: Boolean;
  stripe_user_id?: String;
  stripe_publishable_key?: String;
  access_token?: String;
  refresh_token?: String;
}

export interface MenuUpdateInput {
  name?: String;
  description?: String;
  restaurant?: RestaurantUpdateOneRequiredWithoutMenusInput;
  serviceTimes?: ServiceTimeUpdateManyWithoutMenuInput;
  categories?: MenuCategoryUpdateManyWithoutMenuInput;
}

export interface RestaurantUpdateOneRequiredWithoutMenusInput {
  create?: RestaurantCreateWithoutMenusInput;
  update?: RestaurantUpdateWithoutMenusDataInput;
  upsert?: RestaurantUpsertWithoutMenusInput;
  connect?: RestaurantWhereUniqueInput;
}

export interface RestaurantUpdateWithoutMenusDataInput {
  name?: String;
  email?: String;
  password?: String;
  address?: AddressUpdateOneRequiredWithoutRestaurantInput;
  tel?: String;
  image?: String;
  logo?: String;
  description?: String;
  status?: String;
  tags?: RestaurantUpdatetagsInput;
  openingTimes?: OpeningTimeUpdateManyWithoutRestaurantInput;
  averageBusyPreparationTime?: String;
  averagePreparationTime?: String;
  isConnected?: Boolean;
  stripe_user_id?: String;
  stripe_publishable_key?: String;
  access_token?: String;
  refresh_token?: String;
}

export interface RestaurantUpsertWithoutMenusInput {
  update: RestaurantUpdateWithoutMenusDataInput;
  create: RestaurantCreateWithoutMenusInput;
}

export interface MenuUpdateManyMutationInput {
  name?: String;
  description?: String;
}

export interface MenuCategoryCreateInput {
  id?: ID_Input;
  name: String;
  menu: MenuCreateOneWithoutCategoriesInput;
  description?: String;
  available?: Boolean;
  items?: MenuItemCreateManyWithoutCategoryInput;
}

export interface MenuCreateOneWithoutCategoriesInput {
  create?: MenuCreateWithoutCategoriesInput;
  connect?: MenuWhereUniqueInput;
}

export interface MenuCreateWithoutCategoriesInput {
  id?: ID_Input;
  name: String;
  description?: String;
  restaurant: RestaurantCreateOneWithoutMenusInput;
  serviceTimes?: ServiceTimeCreateManyWithoutMenuInput;
}

export interface MenuCategoryUpdateInput {
  name?: String;
  menu?: MenuUpdateOneRequiredWithoutCategoriesInput;
  description?: String;
  available?: Boolean;
  items?: MenuItemUpdateManyWithoutCategoryInput;
}

export interface MenuUpdateOneRequiredWithoutCategoriesInput {
  create?: MenuCreateWithoutCategoriesInput;
  update?: MenuUpdateWithoutCategoriesDataInput;
  upsert?: MenuUpsertWithoutCategoriesInput;
  connect?: MenuWhereUniqueInput;
}

export interface MenuUpdateWithoutCategoriesDataInput {
  name?: String;
  description?: String;
  restaurant?: RestaurantUpdateOneRequiredWithoutMenusInput;
  serviceTimes?: ServiceTimeUpdateManyWithoutMenuInput;
}

export interface MenuUpsertWithoutCategoriesInput {
  update: MenuUpdateWithoutCategoriesDataInput;
  create: MenuCreateWithoutCategoriesInput;
}

export interface MenuCategoryUpdateManyMutationInput {
  name?: String;
  description?: String;
  available?: Boolean;
}

export interface MenuItemCreateInput {
  id?: ID_Input;
  name?: String;
  description?: String;
  price?: String;
  image?: String;
  available?: Boolean;
  dietary?: MenuItemCreatedietaryInput;
  category?: MenuCategoryCreateOneWithoutItemsInput;
  options?: OptionCreateManyWithoutMenuItemsInput;
}

export interface MenuCategoryCreateOneWithoutItemsInput {
  create?: MenuCategoryCreateWithoutItemsInput;
  connect?: MenuCategoryWhereUniqueInput;
}

export interface MenuCategoryCreateWithoutItemsInput {
  id?: ID_Input;
  name: String;
  menu: MenuCreateOneWithoutCategoriesInput;
  description?: String;
  available?: Boolean;
}

export interface MenuItemUpdateInput {
  name?: String;
  description?: String;
  price?: String;
  image?: String;
  available?: Boolean;
  dietary?: MenuItemUpdatedietaryInput;
  category?: MenuCategoryUpdateOneWithoutItemsInput;
  options?: OptionUpdateManyWithoutMenuItemsInput;
}

export interface MenuCategoryUpdateOneWithoutItemsInput {
  create?: MenuCategoryCreateWithoutItemsInput;
  update?: MenuCategoryUpdateWithoutItemsDataInput;
  upsert?: MenuCategoryUpsertWithoutItemsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: MenuCategoryWhereUniqueInput;
}

export interface MenuCategoryUpdateWithoutItemsDataInput {
  name?: String;
  menu?: MenuUpdateOneRequiredWithoutCategoriesInput;
  description?: String;
  available?: Boolean;
}

export interface MenuCategoryUpsertWithoutItemsInput {
  update: MenuCategoryUpdateWithoutItemsDataInput;
  create: MenuCategoryCreateWithoutItemsInput;
}

export interface MenuItemUpdateManyMutationInput {
  name?: String;
  description?: String;
  price?: String;
  image?: String;
  available?: Boolean;
  dietary?: MenuItemUpdatedietaryInput;
}

export interface OpeningTimeCreateInput {
  id?: ID_Input;
  hours?: OpeningTimeCreatehoursInput;
  days?: OpeningTimeCreatedaysInput;
  restaurant?: RestaurantCreateOneWithoutOpeningTimesInput;
}

export interface RestaurantCreateOneWithoutOpeningTimesInput {
  create?: RestaurantCreateWithoutOpeningTimesInput;
  connect?: RestaurantWhereUniqueInput;
}

export interface RestaurantCreateWithoutOpeningTimesInput {
  id?: ID_Input;
  name: String;
  email: String;
  password: String;
  address: AddressCreateOneWithoutRestaurantInput;
  tel: String;
  image?: String;
  logo?: String;
  description?: String;
  status?: String;
  tags?: RestaurantCreatetagsInput;
  averageBusyPreparationTime?: String;
  averagePreparationTime?: String;
  menus?: MenuCreateManyWithoutRestaurantInput;
  isConnected?: Boolean;
  stripe_user_id?: String;
  stripe_publishable_key?: String;
  access_token?: String;
  refresh_token?: String;
}

export interface OpeningTimeUpdateInput {
  hours?: OpeningTimeUpdatehoursInput;
  days?: OpeningTimeUpdatedaysInput;
  restaurant?: RestaurantUpdateOneWithoutOpeningTimesInput;
}

export interface RestaurantUpdateOneWithoutOpeningTimesInput {
  create?: RestaurantCreateWithoutOpeningTimesInput;
  update?: RestaurantUpdateWithoutOpeningTimesDataInput;
  upsert?: RestaurantUpsertWithoutOpeningTimesInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: RestaurantWhereUniqueInput;
}

export interface RestaurantUpdateWithoutOpeningTimesDataInput {
  name?: String;
  email?: String;
  password?: String;
  address?: AddressUpdateOneRequiredWithoutRestaurantInput;
  tel?: String;
  image?: String;
  logo?: String;
  description?: String;
  status?: String;
  tags?: RestaurantUpdatetagsInput;
  averageBusyPreparationTime?: String;
  averagePreparationTime?: String;
  menus?: MenuUpdateManyWithoutRestaurantInput;
  isConnected?: Boolean;
  stripe_user_id?: String;
  stripe_publishable_key?: String;
  access_token?: String;
  refresh_token?: String;
}

export interface RestaurantUpsertWithoutOpeningTimesInput {
  update: RestaurantUpdateWithoutOpeningTimesDataInput;
  create: RestaurantCreateWithoutOpeningTimesInput;
}

export interface OpeningTimeUpdateManyMutationInput {
  hours?: OpeningTimeUpdatehoursInput;
  days?: OpeningTimeUpdatedaysInput;
}

export interface OptionCreateInput {
  id?: ID_Input;
  name: String;
  min: String;
  max: String;
  items?: OptionItemCreateManyWithoutOptionInput;
  menuItems?: MenuItemCreateManyWithoutOptionsInput;
  restaurant?: RestaurantCreateOneInput;
}

export interface MenuItemCreateManyWithoutOptionsInput {
  create?:
    | MenuItemCreateWithoutOptionsInput[]
    | MenuItemCreateWithoutOptionsInput;
  connect?: MenuItemWhereUniqueInput[] | MenuItemWhereUniqueInput;
}

export interface MenuItemCreateWithoutOptionsInput {
  id?: ID_Input;
  name?: String;
  description?: String;
  price?: String;
  image?: String;
  available?: Boolean;
  dietary?: MenuItemCreatedietaryInput;
  category?: MenuCategoryCreateOneWithoutItemsInput;
}

export interface OptionUpdateInput {
  name?: String;
  min?: String;
  max?: String;
  items?: OptionItemUpdateManyWithoutOptionInput;
  menuItems?: MenuItemUpdateManyWithoutOptionsInput;
  restaurant?: RestaurantUpdateOneInput;
}

export interface MenuItemUpdateManyWithoutOptionsInput {
  create?:
    | MenuItemCreateWithoutOptionsInput[]
    | MenuItemCreateWithoutOptionsInput;
  delete?: MenuItemWhereUniqueInput[] | MenuItemWhereUniqueInput;
  connect?: MenuItemWhereUniqueInput[] | MenuItemWhereUniqueInput;
  set?: MenuItemWhereUniqueInput[] | MenuItemWhereUniqueInput;
  disconnect?: MenuItemWhereUniqueInput[] | MenuItemWhereUniqueInput;
  update?:
    | MenuItemUpdateWithWhereUniqueWithoutOptionsInput[]
    | MenuItemUpdateWithWhereUniqueWithoutOptionsInput;
  upsert?:
    | MenuItemUpsertWithWhereUniqueWithoutOptionsInput[]
    | MenuItemUpsertWithWhereUniqueWithoutOptionsInput;
  deleteMany?: MenuItemScalarWhereInput[] | MenuItemScalarWhereInput;
  updateMany?:
    | MenuItemUpdateManyWithWhereNestedInput[]
    | MenuItemUpdateManyWithWhereNestedInput;
}

export interface MenuItemUpdateWithWhereUniqueWithoutOptionsInput {
  where: MenuItemWhereUniqueInput;
  data: MenuItemUpdateWithoutOptionsDataInput;
}

export interface MenuItemUpdateWithoutOptionsDataInput {
  name?: String;
  description?: String;
  price?: String;
  image?: String;
  available?: Boolean;
  dietary?: MenuItemUpdatedietaryInput;
  category?: MenuCategoryUpdateOneWithoutItemsInput;
}

export interface MenuItemUpsertWithWhereUniqueWithoutOptionsInput {
  where: MenuItemWhereUniqueInput;
  update: MenuItemUpdateWithoutOptionsDataInput;
  create: MenuItemCreateWithoutOptionsInput;
}

export interface OptionUpdateManyMutationInput {
  name?: String;
  min?: String;
  max?: String;
}

export interface OptionItemCreateInput {
  id?: ID_Input;
  name: String;
  price: String;
  option?: OptionCreateOneWithoutItemsInput;
}

export interface OptionCreateOneWithoutItemsInput {
  create?: OptionCreateWithoutItemsInput;
  connect?: OptionWhereUniqueInput;
}

export interface OptionCreateWithoutItemsInput {
  id?: ID_Input;
  name: String;
  min: String;
  max: String;
  menuItems?: MenuItemCreateManyWithoutOptionsInput;
  restaurant?: RestaurantCreateOneInput;
}

export interface OptionItemUpdateInput {
  name?: String;
  price?: String;
  option?: OptionUpdateOneWithoutItemsInput;
}

export interface OptionUpdateOneWithoutItemsInput {
  create?: OptionCreateWithoutItemsInput;
  update?: OptionUpdateWithoutItemsDataInput;
  upsert?: OptionUpsertWithoutItemsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: OptionWhereUniqueInput;
}

export interface OptionUpdateWithoutItemsDataInput {
  name?: String;
  min?: String;
  max?: String;
  menuItems?: MenuItemUpdateManyWithoutOptionsInput;
  restaurant?: RestaurantUpdateOneInput;
}

export interface OptionUpsertWithoutItemsInput {
  update: OptionUpdateWithoutItemsDataInput;
  create: OptionCreateWithoutItemsInput;
}

export interface OptionItemUpdateManyMutationInput {
  name?: String;
  price?: String;
}

export interface OrderCreateInput {
  id?: ID_Input;
  orderNo: Int;
  paymentIntentId?: String;
  status?: String;
  dueAt: DateTimeInput;
  delayedBy?: Int;
  restaurant: RestaurantCreateOneInput;
  customer: CustomerCreateOneWithoutOrdersInput;
  items?: OrderItemCreateManyWithoutOrderInput;
  total: String;
  priceAdjustment?: String;
  cancelReason?: String;
  priceAdjustmentReason?: String;
}

export interface CustomerCreateOneWithoutOrdersInput {
  create?: CustomerCreateWithoutOrdersInput;
  connect?: CustomerWhereUniqueInput;
}

export interface CustomerCreateWithoutOrdersInput {
  id?: ID_Input;
  email: String;
  password: String;
  name: String;
  tel: String;
  customerStripeId?: String;
  paymentMethod?: PaymentMethodCreateOneWithoutCustomerInput;
}

export interface OrderUpdateInput {
  orderNo?: Int;
  paymentIntentId?: String;
  status?: String;
  dueAt?: DateTimeInput;
  delayedBy?: Int;
  restaurant?: RestaurantUpdateOneRequiredInput;
  customer?: CustomerUpdateOneRequiredWithoutOrdersInput;
  items?: OrderItemUpdateManyWithoutOrderInput;
  total?: String;
  priceAdjustment?: String;
  cancelReason?: String;
  priceAdjustmentReason?: String;
}

export interface CustomerUpdateOneRequiredWithoutOrdersInput {
  create?: CustomerCreateWithoutOrdersInput;
  update?: CustomerUpdateWithoutOrdersDataInput;
  upsert?: CustomerUpsertWithoutOrdersInput;
  connect?: CustomerWhereUniqueInput;
}

export interface CustomerUpdateWithoutOrdersDataInput {
  email?: String;
  password?: String;
  name?: String;
  tel?: String;
  customerStripeId?: String;
  paymentMethod?: PaymentMethodUpdateOneWithoutCustomerInput;
}

export interface CustomerUpsertWithoutOrdersInput {
  update: CustomerUpdateWithoutOrdersDataInput;
  create: CustomerCreateWithoutOrdersInput;
}

export interface OrderUpdateManyMutationInput {
  orderNo?: Int;
  paymentIntentId?: String;
  status?: String;
  dueAt?: DateTimeInput;
  delayedBy?: Int;
  total?: String;
  priceAdjustment?: String;
  cancelReason?: String;
  priceAdjustmentReason?: String;
}

export interface OrderItemCreateInput {
  id?: ID_Input;
  name: String;
  price?: String;
  image?: String;
  quantity?: Int;
  options?: OrderItemOptionCreateManyWithoutOrderItemInput;
  order: OrderCreateOneWithoutItemsInput;
}

export interface OrderCreateOneWithoutItemsInput {
  create?: OrderCreateWithoutItemsInput;
  connect?: OrderWhereUniqueInput;
}

export interface OrderCreateWithoutItemsInput {
  id?: ID_Input;
  orderNo: Int;
  paymentIntentId?: String;
  status?: String;
  dueAt: DateTimeInput;
  delayedBy?: Int;
  restaurant: RestaurantCreateOneInput;
  customer: CustomerCreateOneWithoutOrdersInput;
  total: String;
  priceAdjustment?: String;
  cancelReason?: String;
  priceAdjustmentReason?: String;
}

export interface OrderItemUpdateInput {
  name?: String;
  price?: String;
  image?: String;
  quantity?: Int;
  options?: OrderItemOptionUpdateManyWithoutOrderItemInput;
  order?: OrderUpdateOneRequiredWithoutItemsInput;
}

export interface OrderUpdateOneRequiredWithoutItemsInput {
  create?: OrderCreateWithoutItemsInput;
  update?: OrderUpdateWithoutItemsDataInput;
  upsert?: OrderUpsertWithoutItemsInput;
  connect?: OrderWhereUniqueInput;
}

export interface OrderUpdateWithoutItemsDataInput {
  orderNo?: Int;
  paymentIntentId?: String;
  status?: String;
  dueAt?: DateTimeInput;
  delayedBy?: Int;
  restaurant?: RestaurantUpdateOneRequiredInput;
  customer?: CustomerUpdateOneRequiredWithoutOrdersInput;
  total?: String;
  priceAdjustment?: String;
  cancelReason?: String;
  priceAdjustmentReason?: String;
}

export interface OrderUpsertWithoutItemsInput {
  update: OrderUpdateWithoutItemsDataInput;
  create: OrderCreateWithoutItemsInput;
}

export interface OrderItemUpdateManyMutationInput {
  name?: String;
  price?: String;
  image?: String;
  quantity?: Int;
}

export interface OrderItemOptionCreateInput {
  id?: ID_Input;
  name: String;
  items?: OrderItemOptionItemCreateManyWithoutOptionInput;
  orderItem: OrderItemCreateOneWithoutOptionsInput;
}

export interface OrderItemCreateOneWithoutOptionsInput {
  create?: OrderItemCreateWithoutOptionsInput;
  connect?: OrderItemWhereUniqueInput;
}

export interface OrderItemCreateWithoutOptionsInput {
  id?: ID_Input;
  name: String;
  price?: String;
  image?: String;
  quantity?: Int;
  order: OrderCreateOneWithoutItemsInput;
}

export interface OrderItemOptionUpdateInput {
  name?: String;
  items?: OrderItemOptionItemUpdateManyWithoutOptionInput;
  orderItem?: OrderItemUpdateOneRequiredWithoutOptionsInput;
}

export interface OrderItemUpdateOneRequiredWithoutOptionsInput {
  create?: OrderItemCreateWithoutOptionsInput;
  update?: OrderItemUpdateWithoutOptionsDataInput;
  upsert?: OrderItemUpsertWithoutOptionsInput;
  connect?: OrderItemWhereUniqueInput;
}

export interface OrderItemUpdateWithoutOptionsDataInput {
  name?: String;
  price?: String;
  image?: String;
  quantity?: Int;
  order?: OrderUpdateOneRequiredWithoutItemsInput;
}

export interface OrderItemUpsertWithoutOptionsInput {
  update: OrderItemUpdateWithoutOptionsDataInput;
  create: OrderItemCreateWithoutOptionsInput;
}

export interface OrderItemOptionUpdateManyMutationInput {
  name?: String;
}

export interface OrderItemOptionItemCreateInput {
  id?: ID_Input;
  name: String;
  price: String;
  option?: OrderItemOptionCreateOneWithoutItemsInput;
}

export interface OrderItemOptionCreateOneWithoutItemsInput {
  create?: OrderItemOptionCreateWithoutItemsInput;
  connect?: OrderItemOptionWhereUniqueInput;
}

export interface OrderItemOptionCreateWithoutItemsInput {
  id?: ID_Input;
  name: String;
  orderItem: OrderItemCreateOneWithoutOptionsInput;
}

export interface OrderItemOptionItemUpdateInput {
  name?: String;
  price?: String;
  option?: OrderItemOptionUpdateOneWithoutItemsInput;
}

export interface OrderItemOptionUpdateOneWithoutItemsInput {
  create?: OrderItemOptionCreateWithoutItemsInput;
  update?: OrderItemOptionUpdateWithoutItemsDataInput;
  upsert?: OrderItemOptionUpsertWithoutItemsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: OrderItemOptionWhereUniqueInput;
}

export interface OrderItemOptionUpdateWithoutItemsDataInput {
  name?: String;
  orderItem?: OrderItemUpdateOneRequiredWithoutOptionsInput;
}

export interface OrderItemOptionUpsertWithoutItemsInput {
  update: OrderItemOptionUpdateWithoutItemsDataInput;
  create: OrderItemOptionCreateWithoutItemsInput;
}

export interface OrderItemOptionItemUpdateManyMutationInput {
  name?: String;
  price?: String;
}

export interface PaymentMethodCreateInput {
  id?: ID_Input;
  payment_method_id: String;
  brand: String;
  last4: String;
  customer?: CustomerCreateOneWithoutPaymentMethodInput;
}

export interface CustomerCreateOneWithoutPaymentMethodInput {
  create?: CustomerCreateWithoutPaymentMethodInput;
  connect?: CustomerWhereUniqueInput;
}

export interface CustomerCreateWithoutPaymentMethodInput {
  id?: ID_Input;
  email: String;
  password: String;
  name: String;
  tel: String;
  customerStripeId?: String;
  orders?: OrderCreateManyWithoutCustomerInput;
}

export interface PaymentMethodUpdateInput {
  payment_method_id?: String;
  brand?: String;
  last4?: String;
  customer?: CustomerUpdateOneWithoutPaymentMethodInput;
}

export interface CustomerUpdateOneWithoutPaymentMethodInput {
  create?: CustomerCreateWithoutPaymentMethodInput;
  update?: CustomerUpdateWithoutPaymentMethodDataInput;
  upsert?: CustomerUpsertWithoutPaymentMethodInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CustomerWhereUniqueInput;
}

export interface CustomerUpdateWithoutPaymentMethodDataInput {
  email?: String;
  password?: String;
  name?: String;
  tel?: String;
  customerStripeId?: String;
  orders?: OrderUpdateManyWithoutCustomerInput;
}

export interface CustomerUpsertWithoutPaymentMethodInput {
  update: CustomerUpdateWithoutPaymentMethodDataInput;
  create: CustomerCreateWithoutPaymentMethodInput;
}

export interface PaymentMethodUpdateManyMutationInput {
  payment_method_id?: String;
  brand?: String;
  last4?: String;
}

export interface RestaurantUpdateInput {
  name?: String;
  email?: String;
  password?: String;
  address?: AddressUpdateOneRequiredWithoutRestaurantInput;
  tel?: String;
  image?: String;
  logo?: String;
  description?: String;
  status?: String;
  tags?: RestaurantUpdatetagsInput;
  openingTimes?: OpeningTimeUpdateManyWithoutRestaurantInput;
  averageBusyPreparationTime?: String;
  averagePreparationTime?: String;
  menus?: MenuUpdateManyWithoutRestaurantInput;
  isConnected?: Boolean;
  stripe_user_id?: String;
  stripe_publishable_key?: String;
  access_token?: String;
  refresh_token?: String;
}

export interface RestaurantUpdateManyMutationInput {
  name?: String;
  email?: String;
  password?: String;
  tel?: String;
  image?: String;
  logo?: String;
  description?: String;
  status?: String;
  tags?: RestaurantUpdatetagsInput;
  averageBusyPreparationTime?: String;
  averagePreparationTime?: String;
  isConnected?: Boolean;
  stripe_user_id?: String;
  stripe_publishable_key?: String;
  access_token?: String;
  refresh_token?: String;
}

export interface ServiceTimeCreateInput {
  id?: ID_Input;
  hours?: ServiceTimeCreatehoursInput;
  days?: ServiceTimeCreatedaysInput;
  menu?: MenuCreateOneWithoutServiceTimesInput;
}

export interface MenuCreateOneWithoutServiceTimesInput {
  create?: MenuCreateWithoutServiceTimesInput;
  connect?: MenuWhereUniqueInput;
}

export interface MenuCreateWithoutServiceTimesInput {
  id?: ID_Input;
  name: String;
  description?: String;
  restaurant: RestaurantCreateOneWithoutMenusInput;
  categories?: MenuCategoryCreateManyWithoutMenuInput;
}

export interface ServiceTimeUpdateInput {
  hours?: ServiceTimeUpdatehoursInput;
  days?: ServiceTimeUpdatedaysInput;
  menu?: MenuUpdateOneWithoutServiceTimesInput;
}

export interface MenuUpdateOneWithoutServiceTimesInput {
  create?: MenuCreateWithoutServiceTimesInput;
  update?: MenuUpdateWithoutServiceTimesDataInput;
  upsert?: MenuUpsertWithoutServiceTimesInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: MenuWhereUniqueInput;
}

export interface MenuUpdateWithoutServiceTimesDataInput {
  name?: String;
  description?: String;
  restaurant?: RestaurantUpdateOneRequiredWithoutMenusInput;
  categories?: MenuCategoryUpdateManyWithoutMenuInput;
}

export interface MenuUpsertWithoutServiceTimesInput {
  update: MenuUpdateWithoutServiceTimesDataInput;
  create: MenuCreateWithoutServiceTimesInput;
}

export interface ServiceTimeUpdateManyMutationInput {
  hours?: ServiceTimeUpdatehoursInput;
  days?: ServiceTimeUpdatedaysInput;
}

export interface AddressSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AddressWhereInput;
  AND?: AddressSubscriptionWhereInput[] | AddressSubscriptionWhereInput;
  OR?: AddressSubscriptionWhereInput[] | AddressSubscriptionWhereInput;
  NOT?: AddressSubscriptionWhereInput[] | AddressSubscriptionWhereInput;
}

export interface CustomerSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CustomerWhereInput;
  AND?: CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput;
  OR?: CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput;
  NOT?: CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput;
}

export interface MenuSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MenuWhereInput;
  AND?: MenuSubscriptionWhereInput[] | MenuSubscriptionWhereInput;
  OR?: MenuSubscriptionWhereInput[] | MenuSubscriptionWhereInput;
  NOT?: MenuSubscriptionWhereInput[] | MenuSubscriptionWhereInput;
}

export interface MenuCategorySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MenuCategoryWhereInput;
  AND?:
    | MenuCategorySubscriptionWhereInput[]
    | MenuCategorySubscriptionWhereInput;
  OR?:
    | MenuCategorySubscriptionWhereInput[]
    | MenuCategorySubscriptionWhereInput;
  NOT?:
    | MenuCategorySubscriptionWhereInput[]
    | MenuCategorySubscriptionWhereInput;
}

export interface MenuItemSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MenuItemWhereInput;
  AND?: MenuItemSubscriptionWhereInput[] | MenuItemSubscriptionWhereInput;
  OR?: MenuItemSubscriptionWhereInput[] | MenuItemSubscriptionWhereInput;
  NOT?: MenuItemSubscriptionWhereInput[] | MenuItemSubscriptionWhereInput;
}

export interface OpeningTimeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: OpeningTimeWhereInput;
  AND?: OpeningTimeSubscriptionWhereInput[] | OpeningTimeSubscriptionWhereInput;
  OR?: OpeningTimeSubscriptionWhereInput[] | OpeningTimeSubscriptionWhereInput;
  NOT?: OpeningTimeSubscriptionWhereInput[] | OpeningTimeSubscriptionWhereInput;
}

export interface OptionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: OptionWhereInput;
  AND?: OptionSubscriptionWhereInput[] | OptionSubscriptionWhereInput;
  OR?: OptionSubscriptionWhereInput[] | OptionSubscriptionWhereInput;
  NOT?: OptionSubscriptionWhereInput[] | OptionSubscriptionWhereInput;
}

export interface OptionItemSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: OptionItemWhereInput;
  AND?: OptionItemSubscriptionWhereInput[] | OptionItemSubscriptionWhereInput;
  OR?: OptionItemSubscriptionWhereInput[] | OptionItemSubscriptionWhereInput;
  NOT?: OptionItemSubscriptionWhereInput[] | OptionItemSubscriptionWhereInput;
}

export interface OrderSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: OrderWhereInput;
  AND?: OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput;
  OR?: OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput;
  NOT?: OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput;
}

export interface OrderItemSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: OrderItemWhereInput;
  AND?: OrderItemSubscriptionWhereInput[] | OrderItemSubscriptionWhereInput;
  OR?: OrderItemSubscriptionWhereInput[] | OrderItemSubscriptionWhereInput;
  NOT?: OrderItemSubscriptionWhereInput[] | OrderItemSubscriptionWhereInput;
}

export interface OrderItemOptionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: OrderItemOptionWhereInput;
  AND?:
    | OrderItemOptionSubscriptionWhereInput[]
    | OrderItemOptionSubscriptionWhereInput;
  OR?:
    | OrderItemOptionSubscriptionWhereInput[]
    | OrderItemOptionSubscriptionWhereInput;
  NOT?:
    | OrderItemOptionSubscriptionWhereInput[]
    | OrderItemOptionSubscriptionWhereInput;
}

export interface OrderItemOptionItemSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: OrderItemOptionItemWhereInput;
  AND?:
    | OrderItemOptionItemSubscriptionWhereInput[]
    | OrderItemOptionItemSubscriptionWhereInput;
  OR?:
    | OrderItemOptionItemSubscriptionWhereInput[]
    | OrderItemOptionItemSubscriptionWhereInput;
  NOT?:
    | OrderItemOptionItemSubscriptionWhereInput[]
    | OrderItemOptionItemSubscriptionWhereInput;
}

export interface PaymentMethodSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PaymentMethodWhereInput;
  AND?:
    | PaymentMethodSubscriptionWhereInput[]
    | PaymentMethodSubscriptionWhereInput;
  OR?:
    | PaymentMethodSubscriptionWhereInput[]
    | PaymentMethodSubscriptionWhereInput;
  NOT?:
    | PaymentMethodSubscriptionWhereInput[]
    | PaymentMethodSubscriptionWhereInput;
}

export interface RestaurantSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RestaurantWhereInput;
  AND?: RestaurantSubscriptionWhereInput[] | RestaurantSubscriptionWhereInput;
  OR?: RestaurantSubscriptionWhereInput[] | RestaurantSubscriptionWhereInput;
  NOT?: RestaurantSubscriptionWhereInput[] | RestaurantSubscriptionWhereInput;
}

export interface ServiceTimeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ServiceTimeWhereInput;
  AND?: ServiceTimeSubscriptionWhereInput[] | ServiceTimeSubscriptionWhereInput;
  OR?: ServiceTimeSubscriptionWhereInput[] | ServiceTimeSubscriptionWhereInput;
  NOT?: ServiceTimeSubscriptionWhereInput[] | ServiceTimeSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Address {
  id: ID_Output;
  number: String;
  streetName: String;
  city: String;
  postalCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AddressPromise extends Promise<Address>, Fragmentable {
  id: () => Promise<ID_Output>;
  number: () => Promise<String>;
  streetName: () => Promise<String>;
  city: () => Promise<String>;
  postalCode: () => Promise<String>;
  restaurant: <T = RestaurantPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AddressSubscription
  extends Promise<AsyncIterator<Address>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  number: () => Promise<AsyncIterator<String>>;
  streetName: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  postalCode: () => Promise<AsyncIterator<String>>;
  restaurant: <T = RestaurantSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Restaurant {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
  tel: String;
  image?: String;
  logo?: String;
  description?: String;
  status?: String;
  tags: String[];
  averageBusyPreparationTime?: String;
  averagePreparationTime?: String;
  isConnected: Boolean;
  stripe_user_id?: String;
  stripe_publishable_key?: String;
  access_token?: String;
  refresh_token?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface RestaurantPromise extends Promise<Restaurant>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  address: <T = AddressPromise>() => T;
  tel: () => Promise<String>;
  image: () => Promise<String>;
  logo: () => Promise<String>;
  description: () => Promise<String>;
  status: () => Promise<String>;
  tags: () => Promise<String[]>;
  openingTimes: <T = FragmentableArray<OpeningTime>>(args?: {
    where?: OpeningTimeWhereInput;
    orderBy?: OpeningTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  averageBusyPreparationTime: () => Promise<String>;
  averagePreparationTime: () => Promise<String>;
  menus: <T = FragmentableArray<Menu>>(args?: {
    where?: MenuWhereInput;
    orderBy?: MenuOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  isConnected: () => Promise<Boolean>;
  stripe_user_id: () => Promise<String>;
  stripe_publishable_key: () => Promise<String>;
  access_token: () => Promise<String>;
  refresh_token: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface RestaurantSubscription
  extends Promise<AsyncIterator<Restaurant>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  address: <T = AddressSubscription>() => T;
  tel: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  logo: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<String>>;
  tags: () => Promise<AsyncIterator<String[]>>;
  openingTimes: <T = Promise<AsyncIterator<OpeningTimeSubscription>>>(args?: {
    where?: OpeningTimeWhereInput;
    orderBy?: OpeningTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  averageBusyPreparationTime: () => Promise<AsyncIterator<String>>;
  averagePreparationTime: () => Promise<AsyncIterator<String>>;
  menus: <T = Promise<AsyncIterator<MenuSubscription>>>(args?: {
    where?: MenuWhereInput;
    orderBy?: MenuOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  isConnected: () => Promise<AsyncIterator<Boolean>>;
  stripe_user_id: () => Promise<AsyncIterator<String>>;
  stripe_publishable_key: () => Promise<AsyncIterator<String>>;
  access_token: () => Promise<AsyncIterator<String>>;
  refresh_token: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface OpeningTime {
  id: ID_Output;
  hours: String[];
  days: String[];
}

export interface OpeningTimePromise extends Promise<OpeningTime>, Fragmentable {
  id: () => Promise<ID_Output>;
  hours: () => Promise<String[]>;
  days: () => Promise<String[]>;
  restaurant: <T = RestaurantPromise>() => T;
}

export interface OpeningTimeSubscription
  extends Promise<AsyncIterator<OpeningTime>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  hours: () => Promise<AsyncIterator<String[]>>;
  days: () => Promise<AsyncIterator<String[]>>;
  restaurant: <T = RestaurantSubscription>() => T;
}

export interface Menu {
  id: ID_Output;
  name: String;
  description?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface MenuPromise extends Promise<Menu>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  restaurant: <T = RestaurantPromise>() => T;
  serviceTimes: <T = FragmentableArray<ServiceTime>>(args?: {
    where?: ServiceTimeWhereInput;
    orderBy?: ServiceTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  categories: <T = FragmentableArray<MenuCategory>>(args?: {
    where?: MenuCategoryWhereInput;
    orderBy?: MenuCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MenuSubscription
  extends Promise<AsyncIterator<Menu>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  restaurant: <T = RestaurantSubscription>() => T;
  serviceTimes: <T = Promise<AsyncIterator<ServiceTimeSubscription>>>(args?: {
    where?: ServiceTimeWhereInput;
    orderBy?: ServiceTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  categories: <T = Promise<AsyncIterator<MenuCategorySubscription>>>(args?: {
    where?: MenuCategoryWhereInput;
    orderBy?: MenuCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ServiceTime {
  id: ID_Output;
  hours: String[];
  days: String[];
}

export interface ServiceTimePromise extends Promise<ServiceTime>, Fragmentable {
  id: () => Promise<ID_Output>;
  hours: () => Promise<String[]>;
  days: () => Promise<String[]>;
  menu: <T = MenuPromise>() => T;
}

export interface ServiceTimeSubscription
  extends Promise<AsyncIterator<ServiceTime>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  hours: () => Promise<AsyncIterator<String[]>>;
  days: () => Promise<AsyncIterator<String[]>>;
  menu: <T = MenuSubscription>() => T;
}

export interface MenuCategory {
  id: ID_Output;
  name: String;
  description?: String;
  available: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface MenuCategoryPromise
  extends Promise<MenuCategory>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  menu: <T = MenuPromise>() => T;
  description: () => Promise<String>;
  available: () => Promise<Boolean>;
  items: <T = FragmentableArray<MenuItem>>(args?: {
    where?: MenuItemWhereInput;
    orderBy?: MenuItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MenuCategorySubscription
  extends Promise<AsyncIterator<MenuCategory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  menu: <T = MenuSubscription>() => T;
  description: () => Promise<AsyncIterator<String>>;
  available: () => Promise<AsyncIterator<Boolean>>;
  items: <T = Promise<AsyncIterator<MenuItemSubscription>>>(args?: {
    where?: MenuItemWhereInput;
    orderBy?: MenuItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MenuItem {
  id: ID_Output;
  name?: String;
  description?: String;
  price?: String;
  image?: String;
  available: Boolean;
  dietary: String[];
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface MenuItemPromise extends Promise<MenuItem>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  price: () => Promise<String>;
  image: () => Promise<String>;
  available: () => Promise<Boolean>;
  dietary: () => Promise<String[]>;
  category: <T = MenuCategoryPromise>() => T;
  options: <T = FragmentableArray<Option>>(args?: {
    where?: OptionWhereInput;
    orderBy?: OptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MenuItemSubscription
  extends Promise<AsyncIterator<MenuItem>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  available: () => Promise<AsyncIterator<Boolean>>;
  dietary: () => Promise<AsyncIterator<String[]>>;
  category: <T = MenuCategorySubscription>() => T;
  options: <T = Promise<AsyncIterator<OptionSubscription>>>(args?: {
    where?: OptionWhereInput;
    orderBy?: OptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Option {
  id: ID_Output;
  name: String;
  min: String;
  max: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface OptionPromise extends Promise<Option>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  min: () => Promise<String>;
  max: () => Promise<String>;
  items: <T = FragmentableArray<OptionItem>>(args?: {
    where?: OptionItemWhereInput;
    orderBy?: OptionItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  menuItems: <T = FragmentableArray<MenuItem>>(args?: {
    where?: MenuItemWhereInput;
    orderBy?: MenuItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  restaurant: <T = RestaurantPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface OptionSubscription
  extends Promise<AsyncIterator<Option>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  min: () => Promise<AsyncIterator<String>>;
  max: () => Promise<AsyncIterator<String>>;
  items: <T = Promise<AsyncIterator<OptionItemSubscription>>>(args?: {
    where?: OptionItemWhereInput;
    orderBy?: OptionItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  menuItems: <T = Promise<AsyncIterator<MenuItemSubscription>>>(args?: {
    where?: MenuItemWhereInput;
    orderBy?: MenuItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  restaurant: <T = RestaurantSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface OptionItem {
  id: ID_Output;
  name: String;
  price: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface OptionItemPromise extends Promise<OptionItem>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  price: () => Promise<String>;
  option: <T = OptionPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface OptionItemSubscription
  extends Promise<AsyncIterator<OptionItem>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<String>>;
  option: <T = OptionSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AddressConnection {
  pageInfo: PageInfo;
  edges: AddressEdge[];
}

export interface AddressConnectionPromise
  extends Promise<AddressConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AddressEdge>>() => T;
  aggregate: <T = AggregateAddressPromise>() => T;
}

export interface AddressConnectionSubscription
  extends Promise<AsyncIterator<AddressConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AddressEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAddressSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AddressEdge {
  node: Address;
  cursor: String;
}

export interface AddressEdgePromise extends Promise<AddressEdge>, Fragmentable {
  node: <T = AddressPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AddressEdgeSubscription
  extends Promise<AsyncIterator<AddressEdge>>,
    Fragmentable {
  node: <T = AddressSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAddress {
  count: Int;
}

export interface AggregateAddressPromise
  extends Promise<AggregateAddress>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAddressSubscription
  extends Promise<AsyncIterator<AggregateAddress>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Customer {
  id: ID_Output;
  email: String;
  password: String;
  name: String;
  tel: String;
  customerStripeId?: String;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface CustomerPromise extends Promise<Customer>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  name: () => Promise<String>;
  tel: () => Promise<String>;
  customerStripeId: () => Promise<String>;
  orders: <T = FragmentableArray<Order>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  paymentMethod: <T = PaymentMethodPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CustomerSubscription
  extends Promise<AsyncIterator<Customer>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  tel: () => Promise<AsyncIterator<String>>;
  customerStripeId: () => Promise<AsyncIterator<String>>;
  orders: <T = Promise<AsyncIterator<OrderSubscription>>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  paymentMethod: <T = PaymentMethodSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Order {
  id: ID_Output;
  orderNo: Int;
  paymentIntentId?: String;
  status: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  dueAt: DateTimeOutput;
  delayedBy?: Int;
  total: String;
  priceAdjustment?: String;
  cancelReason?: String;
  priceAdjustmentReason?: String;
}

export interface OrderPromise extends Promise<Order>, Fragmentable {
  id: () => Promise<ID_Output>;
  orderNo: () => Promise<Int>;
  paymentIntentId: () => Promise<String>;
  status: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  dueAt: () => Promise<DateTimeOutput>;
  delayedBy: () => Promise<Int>;
  restaurant: <T = RestaurantPromise>() => T;
  customer: <T = CustomerPromise>() => T;
  items: <T = FragmentableArray<OrderItem>>(args?: {
    where?: OrderItemWhereInput;
    orderBy?: OrderItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  total: () => Promise<String>;
  priceAdjustment: () => Promise<String>;
  cancelReason: () => Promise<String>;
  priceAdjustmentReason: () => Promise<String>;
}

export interface OrderSubscription
  extends Promise<AsyncIterator<Order>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  orderNo: () => Promise<AsyncIterator<Int>>;
  paymentIntentId: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  dueAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  delayedBy: () => Promise<AsyncIterator<Int>>;
  restaurant: <T = RestaurantSubscription>() => T;
  customer: <T = CustomerSubscription>() => T;
  items: <T = Promise<AsyncIterator<OrderItemSubscription>>>(args?: {
    where?: OrderItemWhereInput;
    orderBy?: OrderItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  total: () => Promise<AsyncIterator<String>>;
  priceAdjustment: () => Promise<AsyncIterator<String>>;
  cancelReason: () => Promise<AsyncIterator<String>>;
  priceAdjustmentReason: () => Promise<AsyncIterator<String>>;
}

export interface OrderItem {
  id: ID_Output;
  name: String;
  price?: String;
  image?: String;
  quantity?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface OrderItemPromise extends Promise<OrderItem>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  price: () => Promise<String>;
  image: () => Promise<String>;
  quantity: () => Promise<Int>;
  options: <T = FragmentableArray<OrderItemOption>>(args?: {
    where?: OrderItemOptionWhereInput;
    orderBy?: OrderItemOptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  order: <T = OrderPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface OrderItemSubscription
  extends Promise<AsyncIterator<OrderItem>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  quantity: () => Promise<AsyncIterator<Int>>;
  options: <T = Promise<AsyncIterator<OrderItemOptionSubscription>>>(args?: {
    where?: OrderItemOptionWhereInput;
    orderBy?: OrderItemOptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  order: <T = OrderSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface OrderItemOption {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface OrderItemOptionPromise
  extends Promise<OrderItemOption>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  items: <T = FragmentableArray<OrderItemOptionItem>>(args?: {
    where?: OrderItemOptionItemWhereInput;
    orderBy?: OrderItemOptionItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  orderItem: <T = OrderItemPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface OrderItemOptionSubscription
  extends Promise<AsyncIterator<OrderItemOption>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  items: <T = Promise<AsyncIterator<OrderItemOptionItemSubscription>>>(args?: {
    where?: OrderItemOptionItemWhereInput;
    orderBy?: OrderItemOptionItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  orderItem: <T = OrderItemSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface OrderItemOptionItem {
  id: ID_Output;
  name: String;
  price: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface OrderItemOptionItemPromise
  extends Promise<OrderItemOptionItem>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  price: () => Promise<String>;
  option: <T = OrderItemOptionPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface OrderItemOptionItemSubscription
  extends Promise<AsyncIterator<OrderItemOptionItem>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<String>>;
  option: <T = OrderItemOptionSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PaymentMethod {
  id: ID_Output;
  payment_method_id: String;
  brand: String;
  last4: String;
}

export interface PaymentMethodPromise
  extends Promise<PaymentMethod>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  payment_method_id: () => Promise<String>;
  brand: () => Promise<String>;
  last4: () => Promise<String>;
  customer: <T = CustomerPromise>() => T;
}

export interface PaymentMethodSubscription
  extends Promise<AsyncIterator<PaymentMethod>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  payment_method_id: () => Promise<AsyncIterator<String>>;
  brand: () => Promise<AsyncIterator<String>>;
  last4: () => Promise<AsyncIterator<String>>;
  customer: <T = CustomerSubscription>() => T;
}

export interface CustomerConnection {
  pageInfo: PageInfo;
  edges: CustomerEdge[];
}

export interface CustomerConnectionPromise
  extends Promise<CustomerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CustomerEdge>>() => T;
  aggregate: <T = AggregateCustomerPromise>() => T;
}

export interface CustomerConnectionSubscription
  extends Promise<AsyncIterator<CustomerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CustomerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCustomerSubscription>() => T;
}

export interface CustomerEdge {
  node: Customer;
  cursor: String;
}

export interface CustomerEdgePromise
  extends Promise<CustomerEdge>,
    Fragmentable {
  node: <T = CustomerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CustomerEdgeSubscription
  extends Promise<AsyncIterator<CustomerEdge>>,
    Fragmentable {
  node: <T = CustomerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCustomer {
  count: Int;
}

export interface AggregateCustomerPromise
  extends Promise<AggregateCustomer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCustomerSubscription
  extends Promise<AsyncIterator<AggregateCustomer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MenuConnection {
  pageInfo: PageInfo;
  edges: MenuEdge[];
}

export interface MenuConnectionPromise
  extends Promise<MenuConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MenuEdge>>() => T;
  aggregate: <T = AggregateMenuPromise>() => T;
}

export interface MenuConnectionSubscription
  extends Promise<AsyncIterator<MenuConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MenuEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMenuSubscription>() => T;
}

export interface MenuEdge {
  node: Menu;
  cursor: String;
}

export interface MenuEdgePromise extends Promise<MenuEdge>, Fragmentable {
  node: <T = MenuPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MenuEdgeSubscription
  extends Promise<AsyncIterator<MenuEdge>>,
    Fragmentable {
  node: <T = MenuSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMenu {
  count: Int;
}

export interface AggregateMenuPromise
  extends Promise<AggregateMenu>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMenuSubscription
  extends Promise<AsyncIterator<AggregateMenu>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MenuCategoryConnection {
  pageInfo: PageInfo;
  edges: MenuCategoryEdge[];
}

export interface MenuCategoryConnectionPromise
  extends Promise<MenuCategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MenuCategoryEdge>>() => T;
  aggregate: <T = AggregateMenuCategoryPromise>() => T;
}

export interface MenuCategoryConnectionSubscription
  extends Promise<AsyncIterator<MenuCategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MenuCategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMenuCategorySubscription>() => T;
}

export interface MenuCategoryEdge {
  node: MenuCategory;
  cursor: String;
}

export interface MenuCategoryEdgePromise
  extends Promise<MenuCategoryEdge>,
    Fragmentable {
  node: <T = MenuCategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MenuCategoryEdgeSubscription
  extends Promise<AsyncIterator<MenuCategoryEdge>>,
    Fragmentable {
  node: <T = MenuCategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMenuCategory {
  count: Int;
}

export interface AggregateMenuCategoryPromise
  extends Promise<AggregateMenuCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMenuCategorySubscription
  extends Promise<AsyncIterator<AggregateMenuCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MenuItemConnection {
  pageInfo: PageInfo;
  edges: MenuItemEdge[];
}

export interface MenuItemConnectionPromise
  extends Promise<MenuItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MenuItemEdge>>() => T;
  aggregate: <T = AggregateMenuItemPromise>() => T;
}

export interface MenuItemConnectionSubscription
  extends Promise<AsyncIterator<MenuItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MenuItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMenuItemSubscription>() => T;
}

export interface MenuItemEdge {
  node: MenuItem;
  cursor: String;
}

export interface MenuItemEdgePromise
  extends Promise<MenuItemEdge>,
    Fragmentable {
  node: <T = MenuItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MenuItemEdgeSubscription
  extends Promise<AsyncIterator<MenuItemEdge>>,
    Fragmentable {
  node: <T = MenuItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMenuItem {
  count: Int;
}

export interface AggregateMenuItemPromise
  extends Promise<AggregateMenuItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMenuItemSubscription
  extends Promise<AsyncIterator<AggregateMenuItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OpeningTimeConnection {
  pageInfo: PageInfo;
  edges: OpeningTimeEdge[];
}

export interface OpeningTimeConnectionPromise
  extends Promise<OpeningTimeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OpeningTimeEdge>>() => T;
  aggregate: <T = AggregateOpeningTimePromise>() => T;
}

export interface OpeningTimeConnectionSubscription
  extends Promise<AsyncIterator<OpeningTimeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OpeningTimeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOpeningTimeSubscription>() => T;
}

export interface OpeningTimeEdge {
  node: OpeningTime;
  cursor: String;
}

export interface OpeningTimeEdgePromise
  extends Promise<OpeningTimeEdge>,
    Fragmentable {
  node: <T = OpeningTimePromise>() => T;
  cursor: () => Promise<String>;
}

export interface OpeningTimeEdgeSubscription
  extends Promise<AsyncIterator<OpeningTimeEdge>>,
    Fragmentable {
  node: <T = OpeningTimeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOpeningTime {
  count: Int;
}

export interface AggregateOpeningTimePromise
  extends Promise<AggregateOpeningTime>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOpeningTimeSubscription
  extends Promise<AsyncIterator<AggregateOpeningTime>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OptionConnection {
  pageInfo: PageInfo;
  edges: OptionEdge[];
}

export interface OptionConnectionPromise
  extends Promise<OptionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OptionEdge>>() => T;
  aggregate: <T = AggregateOptionPromise>() => T;
}

export interface OptionConnectionSubscription
  extends Promise<AsyncIterator<OptionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OptionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOptionSubscription>() => T;
}

export interface OptionEdge {
  node: Option;
  cursor: String;
}

export interface OptionEdgePromise extends Promise<OptionEdge>, Fragmentable {
  node: <T = OptionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OptionEdgeSubscription
  extends Promise<AsyncIterator<OptionEdge>>,
    Fragmentable {
  node: <T = OptionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOption {
  count: Int;
}

export interface AggregateOptionPromise
  extends Promise<AggregateOption>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOptionSubscription
  extends Promise<AsyncIterator<AggregateOption>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OptionItemConnection {
  pageInfo: PageInfo;
  edges: OptionItemEdge[];
}

export interface OptionItemConnectionPromise
  extends Promise<OptionItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OptionItemEdge>>() => T;
  aggregate: <T = AggregateOptionItemPromise>() => T;
}

export interface OptionItemConnectionSubscription
  extends Promise<AsyncIterator<OptionItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OptionItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOptionItemSubscription>() => T;
}

export interface OptionItemEdge {
  node: OptionItem;
  cursor: String;
}

export interface OptionItemEdgePromise
  extends Promise<OptionItemEdge>,
    Fragmentable {
  node: <T = OptionItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OptionItemEdgeSubscription
  extends Promise<AsyncIterator<OptionItemEdge>>,
    Fragmentable {
  node: <T = OptionItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOptionItem {
  count: Int;
}

export interface AggregateOptionItemPromise
  extends Promise<AggregateOptionItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOptionItemSubscription
  extends Promise<AsyncIterator<AggregateOptionItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OrderConnection {
  pageInfo: PageInfo;
  edges: OrderEdge[];
}

export interface OrderConnectionPromise
  extends Promise<OrderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrderEdge>>() => T;
  aggregate: <T = AggregateOrderPromise>() => T;
}

export interface OrderConnectionSubscription
  extends Promise<AsyncIterator<OrderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OrderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOrderSubscription>() => T;
}

export interface OrderEdge {
  node: Order;
  cursor: String;
}

export interface OrderEdgePromise extends Promise<OrderEdge>, Fragmentable {
  node: <T = OrderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrderEdgeSubscription
  extends Promise<AsyncIterator<OrderEdge>>,
    Fragmentable {
  node: <T = OrderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOrder {
  count: Int;
}

export interface AggregateOrderPromise
  extends Promise<AggregateOrder>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrderSubscription
  extends Promise<AsyncIterator<AggregateOrder>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OrderItemConnection {
  pageInfo: PageInfo;
  edges: OrderItemEdge[];
}

export interface OrderItemConnectionPromise
  extends Promise<OrderItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrderItemEdge>>() => T;
  aggregate: <T = AggregateOrderItemPromise>() => T;
}

export interface OrderItemConnectionSubscription
  extends Promise<AsyncIterator<OrderItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OrderItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOrderItemSubscription>() => T;
}

export interface OrderItemEdge {
  node: OrderItem;
  cursor: String;
}

export interface OrderItemEdgePromise
  extends Promise<OrderItemEdge>,
    Fragmentable {
  node: <T = OrderItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrderItemEdgeSubscription
  extends Promise<AsyncIterator<OrderItemEdge>>,
    Fragmentable {
  node: <T = OrderItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOrderItem {
  count: Int;
}

export interface AggregateOrderItemPromise
  extends Promise<AggregateOrderItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrderItemSubscription
  extends Promise<AsyncIterator<AggregateOrderItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OrderItemOptionConnection {
  pageInfo: PageInfo;
  edges: OrderItemOptionEdge[];
}

export interface OrderItemOptionConnectionPromise
  extends Promise<OrderItemOptionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrderItemOptionEdge>>() => T;
  aggregate: <T = AggregateOrderItemOptionPromise>() => T;
}

export interface OrderItemOptionConnectionSubscription
  extends Promise<AsyncIterator<OrderItemOptionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OrderItemOptionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOrderItemOptionSubscription>() => T;
}

export interface OrderItemOptionEdge {
  node: OrderItemOption;
  cursor: String;
}

export interface OrderItemOptionEdgePromise
  extends Promise<OrderItemOptionEdge>,
    Fragmentable {
  node: <T = OrderItemOptionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrderItemOptionEdgeSubscription
  extends Promise<AsyncIterator<OrderItemOptionEdge>>,
    Fragmentable {
  node: <T = OrderItemOptionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOrderItemOption {
  count: Int;
}

export interface AggregateOrderItemOptionPromise
  extends Promise<AggregateOrderItemOption>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrderItemOptionSubscription
  extends Promise<AsyncIterator<AggregateOrderItemOption>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OrderItemOptionItemConnection {
  pageInfo: PageInfo;
  edges: OrderItemOptionItemEdge[];
}

export interface OrderItemOptionItemConnectionPromise
  extends Promise<OrderItemOptionItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrderItemOptionItemEdge>>() => T;
  aggregate: <T = AggregateOrderItemOptionItemPromise>() => T;
}

export interface OrderItemOptionItemConnectionSubscription
  extends Promise<AsyncIterator<OrderItemOptionItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<OrderItemOptionItemEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateOrderItemOptionItemSubscription>() => T;
}

export interface OrderItemOptionItemEdge {
  node: OrderItemOptionItem;
  cursor: String;
}

export interface OrderItemOptionItemEdgePromise
  extends Promise<OrderItemOptionItemEdge>,
    Fragmentable {
  node: <T = OrderItemOptionItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrderItemOptionItemEdgeSubscription
  extends Promise<AsyncIterator<OrderItemOptionItemEdge>>,
    Fragmentable {
  node: <T = OrderItemOptionItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOrderItemOptionItem {
  count: Int;
}

export interface AggregateOrderItemOptionItemPromise
  extends Promise<AggregateOrderItemOptionItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrderItemOptionItemSubscription
  extends Promise<AsyncIterator<AggregateOrderItemOptionItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PaymentMethodConnection {
  pageInfo: PageInfo;
  edges: PaymentMethodEdge[];
}

export interface PaymentMethodConnectionPromise
  extends Promise<PaymentMethodConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PaymentMethodEdge>>() => T;
  aggregate: <T = AggregatePaymentMethodPromise>() => T;
}

export interface PaymentMethodConnectionSubscription
  extends Promise<AsyncIterator<PaymentMethodConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PaymentMethodEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePaymentMethodSubscription>() => T;
}

export interface PaymentMethodEdge {
  node: PaymentMethod;
  cursor: String;
}

export interface PaymentMethodEdgePromise
  extends Promise<PaymentMethodEdge>,
    Fragmentable {
  node: <T = PaymentMethodPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PaymentMethodEdgeSubscription
  extends Promise<AsyncIterator<PaymentMethodEdge>>,
    Fragmentable {
  node: <T = PaymentMethodSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePaymentMethod {
  count: Int;
}

export interface AggregatePaymentMethodPromise
  extends Promise<AggregatePaymentMethod>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePaymentMethodSubscription
  extends Promise<AsyncIterator<AggregatePaymentMethod>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RestaurantConnection {
  pageInfo: PageInfo;
  edges: RestaurantEdge[];
}

export interface RestaurantConnectionPromise
  extends Promise<RestaurantConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RestaurantEdge>>() => T;
  aggregate: <T = AggregateRestaurantPromise>() => T;
}

export interface RestaurantConnectionSubscription
  extends Promise<AsyncIterator<RestaurantConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RestaurantEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRestaurantSubscription>() => T;
}

export interface RestaurantEdge {
  node: Restaurant;
  cursor: String;
}

export interface RestaurantEdgePromise
  extends Promise<RestaurantEdge>,
    Fragmentable {
  node: <T = RestaurantPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RestaurantEdgeSubscription
  extends Promise<AsyncIterator<RestaurantEdge>>,
    Fragmentable {
  node: <T = RestaurantSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRestaurant {
  count: Int;
}

export interface AggregateRestaurantPromise
  extends Promise<AggregateRestaurant>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRestaurantSubscription
  extends Promise<AsyncIterator<AggregateRestaurant>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ServiceTimeConnection {
  pageInfo: PageInfo;
  edges: ServiceTimeEdge[];
}

export interface ServiceTimeConnectionPromise
  extends Promise<ServiceTimeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ServiceTimeEdge>>() => T;
  aggregate: <T = AggregateServiceTimePromise>() => T;
}

export interface ServiceTimeConnectionSubscription
  extends Promise<AsyncIterator<ServiceTimeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ServiceTimeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateServiceTimeSubscription>() => T;
}

export interface ServiceTimeEdge {
  node: ServiceTime;
  cursor: String;
}

export interface ServiceTimeEdgePromise
  extends Promise<ServiceTimeEdge>,
    Fragmentable {
  node: <T = ServiceTimePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ServiceTimeEdgeSubscription
  extends Promise<AsyncIterator<ServiceTimeEdge>>,
    Fragmentable {
  node: <T = ServiceTimeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateServiceTime {
  count: Int;
}

export interface AggregateServiceTimePromise
  extends Promise<AggregateServiceTime>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateServiceTimeSubscription
  extends Promise<AsyncIterator<AggregateServiceTime>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AddressSubscriptionPayload {
  mutation: MutationType;
  node: Address;
  updatedFields: String[];
  previousValues: AddressPreviousValues;
}

export interface AddressSubscriptionPayloadPromise
  extends Promise<AddressSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AddressPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AddressPreviousValuesPromise>() => T;
}

export interface AddressSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AddressSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AddressSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AddressPreviousValuesSubscription>() => T;
}

export interface AddressPreviousValues {
  id: ID_Output;
  number: String;
  streetName: String;
  city: String;
  postalCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AddressPreviousValuesPromise
  extends Promise<AddressPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  number: () => Promise<String>;
  streetName: () => Promise<String>;
  city: () => Promise<String>;
  postalCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AddressPreviousValuesSubscription
  extends Promise<AsyncIterator<AddressPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  number: () => Promise<AsyncIterator<String>>;
  streetName: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  postalCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CustomerSubscriptionPayload {
  mutation: MutationType;
  node: Customer;
  updatedFields: String[];
  previousValues: CustomerPreviousValues;
}

export interface CustomerSubscriptionPayloadPromise
  extends Promise<CustomerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CustomerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CustomerPreviousValuesPromise>() => T;
}

export interface CustomerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CustomerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CustomerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CustomerPreviousValuesSubscription>() => T;
}

export interface CustomerPreviousValues {
  id: ID_Output;
  email: String;
  password: String;
  name: String;
  tel: String;
  customerStripeId?: String;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface CustomerPreviousValuesPromise
  extends Promise<CustomerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  name: () => Promise<String>;
  tel: () => Promise<String>;
  customerStripeId: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CustomerPreviousValuesSubscription
  extends Promise<AsyncIterator<CustomerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  tel: () => Promise<AsyncIterator<String>>;
  customerStripeId: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MenuSubscriptionPayload {
  mutation: MutationType;
  node: Menu;
  updatedFields: String[];
  previousValues: MenuPreviousValues;
}

export interface MenuSubscriptionPayloadPromise
  extends Promise<MenuSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MenuPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MenuPreviousValuesPromise>() => T;
}

export interface MenuSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MenuSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MenuSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MenuPreviousValuesSubscription>() => T;
}

export interface MenuPreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface MenuPreviousValuesPromise
  extends Promise<MenuPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MenuPreviousValuesSubscription
  extends Promise<AsyncIterator<MenuPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MenuCategorySubscriptionPayload {
  mutation: MutationType;
  node: MenuCategory;
  updatedFields: String[];
  previousValues: MenuCategoryPreviousValues;
}

export interface MenuCategorySubscriptionPayloadPromise
  extends Promise<MenuCategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MenuCategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MenuCategoryPreviousValuesPromise>() => T;
}

export interface MenuCategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MenuCategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MenuCategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MenuCategoryPreviousValuesSubscription>() => T;
}

export interface MenuCategoryPreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
  available: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface MenuCategoryPreviousValuesPromise
  extends Promise<MenuCategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  available: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MenuCategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<MenuCategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  available: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MenuItemSubscriptionPayload {
  mutation: MutationType;
  node: MenuItem;
  updatedFields: String[];
  previousValues: MenuItemPreviousValues;
}

export interface MenuItemSubscriptionPayloadPromise
  extends Promise<MenuItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MenuItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MenuItemPreviousValuesPromise>() => T;
}

export interface MenuItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MenuItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MenuItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MenuItemPreviousValuesSubscription>() => T;
}

export interface MenuItemPreviousValues {
  id: ID_Output;
  name?: String;
  description?: String;
  price?: String;
  image?: String;
  available: Boolean;
  dietary: String[];
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface MenuItemPreviousValuesPromise
  extends Promise<MenuItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  price: () => Promise<String>;
  image: () => Promise<String>;
  available: () => Promise<Boolean>;
  dietary: () => Promise<String[]>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MenuItemPreviousValuesSubscription
  extends Promise<AsyncIterator<MenuItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  available: () => Promise<AsyncIterator<Boolean>>;
  dietary: () => Promise<AsyncIterator<String[]>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface OpeningTimeSubscriptionPayload {
  mutation: MutationType;
  node: OpeningTime;
  updatedFields: String[];
  previousValues: OpeningTimePreviousValues;
}

export interface OpeningTimeSubscriptionPayloadPromise
  extends Promise<OpeningTimeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OpeningTimePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OpeningTimePreviousValuesPromise>() => T;
}

export interface OpeningTimeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OpeningTimeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OpeningTimeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OpeningTimePreviousValuesSubscription>() => T;
}

export interface OpeningTimePreviousValues {
  id: ID_Output;
  hours: String[];
  days: String[];
}

export interface OpeningTimePreviousValuesPromise
  extends Promise<OpeningTimePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  hours: () => Promise<String[]>;
  days: () => Promise<String[]>;
}

export interface OpeningTimePreviousValuesSubscription
  extends Promise<AsyncIterator<OpeningTimePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  hours: () => Promise<AsyncIterator<String[]>>;
  days: () => Promise<AsyncIterator<String[]>>;
}

export interface OptionSubscriptionPayload {
  mutation: MutationType;
  node: Option;
  updatedFields: String[];
  previousValues: OptionPreviousValues;
}

export interface OptionSubscriptionPayloadPromise
  extends Promise<OptionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OptionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OptionPreviousValuesPromise>() => T;
}

export interface OptionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OptionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OptionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OptionPreviousValuesSubscription>() => T;
}

export interface OptionPreviousValues {
  id: ID_Output;
  name: String;
  min: String;
  max: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface OptionPreviousValuesPromise
  extends Promise<OptionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  min: () => Promise<String>;
  max: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface OptionPreviousValuesSubscription
  extends Promise<AsyncIterator<OptionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  min: () => Promise<AsyncIterator<String>>;
  max: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface OptionItemSubscriptionPayload {
  mutation: MutationType;
  node: OptionItem;
  updatedFields: String[];
  previousValues: OptionItemPreviousValues;
}

export interface OptionItemSubscriptionPayloadPromise
  extends Promise<OptionItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OptionItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OptionItemPreviousValuesPromise>() => T;
}

export interface OptionItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OptionItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OptionItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OptionItemPreviousValuesSubscription>() => T;
}

export interface OptionItemPreviousValues {
  id: ID_Output;
  name: String;
  price: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface OptionItemPreviousValuesPromise
  extends Promise<OptionItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  price: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface OptionItemPreviousValuesSubscription
  extends Promise<AsyncIterator<OptionItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface OrderSubscriptionPayload {
  mutation: MutationType;
  node: Order;
  updatedFields: String[];
  previousValues: OrderPreviousValues;
}

export interface OrderSubscriptionPayloadPromise
  extends Promise<OrderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrderPreviousValuesPromise>() => T;
}

export interface OrderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrderPreviousValuesSubscription>() => T;
}

export interface OrderPreviousValues {
  id: ID_Output;
  orderNo: Int;
  paymentIntentId?: String;
  status: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  dueAt: DateTimeOutput;
  delayedBy?: Int;
  total: String;
  priceAdjustment?: String;
  cancelReason?: String;
  priceAdjustmentReason?: String;
}

export interface OrderPreviousValuesPromise
  extends Promise<OrderPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  orderNo: () => Promise<Int>;
  paymentIntentId: () => Promise<String>;
  status: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  dueAt: () => Promise<DateTimeOutput>;
  delayedBy: () => Promise<Int>;
  total: () => Promise<String>;
  priceAdjustment: () => Promise<String>;
  cancelReason: () => Promise<String>;
  priceAdjustmentReason: () => Promise<String>;
}

export interface OrderPreviousValuesSubscription
  extends Promise<AsyncIterator<OrderPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  orderNo: () => Promise<AsyncIterator<Int>>;
  paymentIntentId: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  dueAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  delayedBy: () => Promise<AsyncIterator<Int>>;
  total: () => Promise<AsyncIterator<String>>;
  priceAdjustment: () => Promise<AsyncIterator<String>>;
  cancelReason: () => Promise<AsyncIterator<String>>;
  priceAdjustmentReason: () => Promise<AsyncIterator<String>>;
}

export interface OrderItemSubscriptionPayload {
  mutation: MutationType;
  node: OrderItem;
  updatedFields: String[];
  previousValues: OrderItemPreviousValues;
}

export interface OrderItemSubscriptionPayloadPromise
  extends Promise<OrderItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrderItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrderItemPreviousValuesPromise>() => T;
}

export interface OrderItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrderItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrderItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrderItemPreviousValuesSubscription>() => T;
}

export interface OrderItemPreviousValues {
  id: ID_Output;
  name: String;
  price?: String;
  image?: String;
  quantity?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface OrderItemPreviousValuesPromise
  extends Promise<OrderItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  price: () => Promise<String>;
  image: () => Promise<String>;
  quantity: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface OrderItemPreviousValuesSubscription
  extends Promise<AsyncIterator<OrderItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  quantity: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface OrderItemOptionSubscriptionPayload {
  mutation: MutationType;
  node: OrderItemOption;
  updatedFields: String[];
  previousValues: OrderItemOptionPreviousValues;
}

export interface OrderItemOptionSubscriptionPayloadPromise
  extends Promise<OrderItemOptionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrderItemOptionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrderItemOptionPreviousValuesPromise>() => T;
}

export interface OrderItemOptionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrderItemOptionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrderItemOptionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrderItemOptionPreviousValuesSubscription>() => T;
}

export interface OrderItemOptionPreviousValues {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface OrderItemOptionPreviousValuesPromise
  extends Promise<OrderItemOptionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface OrderItemOptionPreviousValuesSubscription
  extends Promise<AsyncIterator<OrderItemOptionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface OrderItemOptionItemSubscriptionPayload {
  mutation: MutationType;
  node: OrderItemOptionItem;
  updatedFields: String[];
  previousValues: OrderItemOptionItemPreviousValues;
}

export interface OrderItemOptionItemSubscriptionPayloadPromise
  extends Promise<OrderItemOptionItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrderItemOptionItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrderItemOptionItemPreviousValuesPromise>() => T;
}

export interface OrderItemOptionItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrderItemOptionItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrderItemOptionItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrderItemOptionItemPreviousValuesSubscription>() => T;
}

export interface OrderItemOptionItemPreviousValues {
  id: ID_Output;
  name: String;
  price: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface OrderItemOptionItemPreviousValuesPromise
  extends Promise<OrderItemOptionItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  price: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface OrderItemOptionItemPreviousValuesSubscription
  extends Promise<AsyncIterator<OrderItemOptionItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PaymentMethodSubscriptionPayload {
  mutation: MutationType;
  node: PaymentMethod;
  updatedFields: String[];
  previousValues: PaymentMethodPreviousValues;
}

export interface PaymentMethodSubscriptionPayloadPromise
  extends Promise<PaymentMethodSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PaymentMethodPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PaymentMethodPreviousValuesPromise>() => T;
}

export interface PaymentMethodSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PaymentMethodSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PaymentMethodSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PaymentMethodPreviousValuesSubscription>() => T;
}

export interface PaymentMethodPreviousValues {
  id: ID_Output;
  payment_method_id: String;
  brand: String;
  last4: String;
}

export interface PaymentMethodPreviousValuesPromise
  extends Promise<PaymentMethodPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  payment_method_id: () => Promise<String>;
  brand: () => Promise<String>;
  last4: () => Promise<String>;
}

export interface PaymentMethodPreviousValuesSubscription
  extends Promise<AsyncIterator<PaymentMethodPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  payment_method_id: () => Promise<AsyncIterator<String>>;
  brand: () => Promise<AsyncIterator<String>>;
  last4: () => Promise<AsyncIterator<String>>;
}

export interface RestaurantSubscriptionPayload {
  mutation: MutationType;
  node: Restaurant;
  updatedFields: String[];
  previousValues: RestaurantPreviousValues;
}

export interface RestaurantSubscriptionPayloadPromise
  extends Promise<RestaurantSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RestaurantPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RestaurantPreviousValuesPromise>() => T;
}

export interface RestaurantSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RestaurantSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RestaurantSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RestaurantPreviousValuesSubscription>() => T;
}

export interface RestaurantPreviousValues {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
  tel: String;
  image?: String;
  logo?: String;
  description?: String;
  status?: String;
  tags: String[];
  averageBusyPreparationTime?: String;
  averagePreparationTime?: String;
  isConnected: Boolean;
  stripe_user_id?: String;
  stripe_publishable_key?: String;
  access_token?: String;
  refresh_token?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface RestaurantPreviousValuesPromise
  extends Promise<RestaurantPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  tel: () => Promise<String>;
  image: () => Promise<String>;
  logo: () => Promise<String>;
  description: () => Promise<String>;
  status: () => Promise<String>;
  tags: () => Promise<String[]>;
  averageBusyPreparationTime: () => Promise<String>;
  averagePreparationTime: () => Promise<String>;
  isConnected: () => Promise<Boolean>;
  stripe_user_id: () => Promise<String>;
  stripe_publishable_key: () => Promise<String>;
  access_token: () => Promise<String>;
  refresh_token: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface RestaurantPreviousValuesSubscription
  extends Promise<AsyncIterator<RestaurantPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  tel: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  logo: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<String>>;
  tags: () => Promise<AsyncIterator<String[]>>;
  averageBusyPreparationTime: () => Promise<AsyncIterator<String>>;
  averagePreparationTime: () => Promise<AsyncIterator<String>>;
  isConnected: () => Promise<AsyncIterator<Boolean>>;
  stripe_user_id: () => Promise<AsyncIterator<String>>;
  stripe_publishable_key: () => Promise<AsyncIterator<String>>;
  access_token: () => Promise<AsyncIterator<String>>;
  refresh_token: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ServiceTimeSubscriptionPayload {
  mutation: MutationType;
  node: ServiceTime;
  updatedFields: String[];
  previousValues: ServiceTimePreviousValues;
}

export interface ServiceTimeSubscriptionPayloadPromise
  extends Promise<ServiceTimeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ServiceTimePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ServiceTimePreviousValuesPromise>() => T;
}

export interface ServiceTimeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ServiceTimeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ServiceTimeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ServiceTimePreviousValuesSubscription>() => T;
}

export interface ServiceTimePreviousValues {
  id: ID_Output;
  hours: String[];
  days: String[];
}

export interface ServiceTimePreviousValuesPromise
  extends Promise<ServiceTimePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  hours: () => Promise<String[]>;
  days: () => Promise<String[]>;
}

export interface ServiceTimePreviousValuesSubscription
  extends Promise<AsyncIterator<ServiceTimePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  hours: () => Promise<AsyncIterator<String[]>>;
  days: () => Promise<AsyncIterator<String[]>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Customer",
    embedded: false
  },
  {
    name: "PaymentMethod",
    embedded: false
  },
  {
    name: "Address",
    embedded: false
  },
  {
    name: "Restaurant",
    embedded: false
  },
  {
    name: "OpeningTime",
    embedded: false
  },
  {
    name: "ServiceTime",
    embedded: false
  },
  {
    name: "Menu",
    embedded: false
  },
  {
    name: "MenuCategory",
    embedded: false
  },
  {
    name: "MenuItem",
    embedded: false
  },
  {
    name: "OptionItem",
    embedded: false
  },
  {
    name: "Option",
    embedded: false
  },
  {
    name: "OrderItemOptionItem",
    embedded: false
  },
  {
    name: "OrderItemOption",
    embedded: false
  },
  {
    name: "OrderItem",
    embedded: false
  },
  {
    name: "Order",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://localhost:4466`
});
export const prisma = new Prisma();
